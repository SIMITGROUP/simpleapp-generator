import { Injectable } from '@nestjs/common';
import { InjectModel } from '@nestjs/mongoose';
import { Model } from 'mongoose';
import Ajv from 'ajv';
import addFormats from 'ajv-formats';
import addErrors from 'ajv-errors';
import foreignkeys from '../dicts/foreignkeys.json';

import {
  NotFoundException,
  InternalServerErrorException,
} from '@nestjs/common/exceptions';
import { User } from './User';

export enum IsolationType {
  'org' = 'org',
  'tenant' = 'tenant',
  'branch' = 'branch',
}
export enum HookType {
  'init'='init',
  'beforeSearch'='beforeSearch',
  'afterSearch'='afterSearch',
  'beforeValidation'='beforeValidation',
  'afterValidation'='afterValidation',
  'beforeCreate'='beforeCreate',
  'afterCreate'='afterCreate',
  'beforeUpdate'='beforeUpdate',
  'afterUpdate'='afterUpdate',
  'beforeDelete'='beforeDelete',
  'afterDelete'='afterDelete',
  'beforeFetchRecord'='beforeFetchRecord',
  'afterFetchRecord'='afterFetchRecord',


}
export type MoreProjectionType = {
  [key:string]:string
}
@Injectable()
export class SimpleAppService<T extends { _id?: string }> {
  protected jsonschema = { type: 'object', properties: {}, required: [] };
  protected documentIdentityCode = 'code';
  protected documentIdentityName = 'label';
  protected documentName = '-unknowndocname-';
  protected documentType = '-unknowndoctype-';
  protected LIMITPERPAGE = 20;
  protected moreAutoCompleteField:MoreProjectionType={}
  protected isolationtype: IsolationType = IsolationType.org;
  protected isolationFilter: any = {};
  protected data: T = { _id: '' } as T;
  private doc: Model<T>; //set private to prevent developer break data isolation control
  protected errorlist = [];
  constructor(
    doctype:string,
    docname:string,
    newdoc: Model<T>,
    isolationtype: IsolationType = IsolationType.org,
  ) {
    this.documentType=doctype
    this.documentName=docname
    this.doc = newdoc;
    this.isolationtype = isolationtype;
    this.hook(HookType.init,this.documentName)
    // this.tenantdoc = tenantdoc
  }
  getRecordId = (): string => this.data._id;
  setSchema = (newschema) => (this.jsonschema = newschema);
  getSchema = () => this.doc.schema.obj;
  getData = () => {
    //console.log('thisdata', this.data);
    return this.data;
  };
  setData = (newdata: T) => {
    delete newdata._id;
    this.data = { ...newdata };
    return this;
  };
  getIsolationFilter = () => {
    let isolationFilter = {};
    switch (this.isolationtype) {
      case 'branch':
        isolationFilter = User.getInstance().getBranchFilter();
        break;
      case 'tenant':
        isolationFilter = User.getInstance().getTenantFilter();
        break;
      case 'org':
      default:
        isolationFilter = User.getInstance().getOrgFilter();
        break;
    }
    return isolationFilter;
  };
  async list() {
    try {
      //console.log("this.isolationFilter",this.getIsolationFilter())
      const products = await this.doc.find(this.getIsolationFilter());
      // console.log(products)
      const productlist = products.map((p: T) => {
        return p;
      });
      //   console.log(products);
      return productlist;
    } catch (err) {
      throw new InternalServerErrorException(err.message);
    }
  }
  addAutoCompleteField = (morefield:MoreProjectionType)=>{
    const props = Object.getOwnPropertyNames(morefield)
    console.log('addAutoCompleteField',props)
    for(let i=0;i<props.length;i++){
      const key = props[i]
      this.moreAutoCompleteField[key] = '$'+morefield[key]
    }
    console.log(this.moreAutoCompleteField)
  }
  async getAutoComplete(keyword: string) {
    try {
      const filter1 = {};
      const filter2 = {};
      filter1[this.documentIdentityCode] = { $regex: keyword };
      filter2[this.documentIdentityName] = { $regex: keyword };
      const filterobj = { $or: [filter1, filter2] };

      Object.assign(filterobj, this.getIsolationFilter());
      let projections = {
        id: `\$_id`,
        label: `\$${this.documentIdentityCode}`,
        name: `\$${this.documentIdentityName}`,
      };
      if(this.moreAutoCompleteField){
        Object.assign(projections,this.moreAutoCompleteField)
      }
      const products = await this.doc.find(filterobj, projections, {
        limit: this.LIMITPERPAGE,
      });
      const productlist = products.map((p: T) => {
        return p;
      });
      return productlist;
    } catch (err) {
      throw new InternalServerErrorException(err.message);
    }
  }
  async search(filters: Object) {
    try {
      
      Object.assign(filters, this.getIsolationFilter());
      await this.hook(HookType.beforeSearch,filters)
      const products = await this.doc.find(filters);
      const productlist = products.map((p: T) => {
        return p;
      });
      await this.hook(HookType.afterSearch,productlist)
      //   console.log(products);
      return productlist;
    } catch (err) {
      throw new InternalServerErrorException(err.message);
    }
    // return this;
  }
  async findById(id: string) {
    await this.hook(HookType.beforeFetchRecord,id)
    const data = await this.search({ _id: id });
    await this.hook(HookType.afterFetchRecord,data)
    if (data.length == 1) {
      // console.log('data0', data[0]);
      return data[0];
    } else {
      return null;
    }
  }

  async create() {
    let result;

    try {
      await this.hook(HookType.beforeCreate,this.data)
      Object.assign(this.data, User.getInstance().getCreateFilter());
      delete this.data._id;
      await this.validateData(this.data);
      const newdoc = new this.doc(this.data);
      result = await newdoc.save();
      await this.hook(HookType.afterCreate,result)
    } catch (err) {
      throw new InternalServerErrorException(err.message);
    }
    return result as T;
  }
  async update() {
    const id: string = this.getRecordId();
    Object.assign(this.data, User.getInstance().getUpdateFilter());
    await this.findIdThenUpdate(id, this.data);
  }
  async delete() {
    const id: string = this.getRecordId();
    const dependency = await this.getRelatedRecords(id);
    if (!dependency) {
      return await this.findIdThenDelete(id);
    } else {
      return dependency;
    }
  }
  hook = async (type: string, data?: any) =>{
    console.log("Default hook",data)
    return true;
  }
  async validateData(data: T) {
    const ajv = new Ajv({ allErrors: true });
    addFormats(ajv);
    addErrors(ajv);

    ajv.addFormat('x-document-no', /.*$/);
    ajv.addFormat('x-document-name', /.*$/);
    ajv.addFormat('x-text', /.*$/);
    ajv.addFormat('tel', /^$|^\d{7,15}$/gm);
    ajv.addFormat('x-html', /.*$/);
    ajv.addKeyword({
      keyword: 'x-foreignkey',
      type: 'string',
    });

    const issuccess = await this.hook(HookType.beforeValidation, data)
    if (!issuccess) {
      const erromsg: string[] = [];
      for (let i = 0; i < this.errorlist.length; i++) {
        erromsg.push(this.errorlist[i].message);
      }
      
      throw new InternalServerErrorException(erromsg.join('\n'));
    }
    const validate = ajv.compile(this.jsonschema);
    const valid = validate(data);
    //console.log(validate.errors);
    if (!valid) {
      // console.log(validate.errors);
      const erromsg: string[] = [];
      for (let i = 0; i < ajv.errors.length; i++) {
        erromsg.push(ajv.errors[i].message);
      }
      console.log('ajv erromsg: ', erromsg);
      throw new InternalServerErrorException(erromsg.join('\n'));
    }
    await this.hook(HookType.afterValidation, data);
  }

  async findIdThenDelete(id: string): Promise<any> {
    // const data = await this.findById(id);
    try {
      await this.hook(HookType.beforeDelete,id)
      //console.log('deletedeletedeletedelete');
      const dependency = await this.getRelatedRecords(id);
      if (!dependency) {
        let filter = this.getIsolationFilter();
        filter['_id'] = id;
        const deleteresult = await this.doc.deleteOne(filter);
        // this.doc.findByIdAndDelete(id)
        await this.hook(HookType.afterDelete,deleteresult)
        //this.doc.findByIdAndDelete(id);
        return deleteresult;
      } else {
        return Promise.reject(dependency);
      }
    } catch (err) {
      throw new InternalServerErrorException(err.message);
    }
  }

  updateOne = async (data: T) => {
    this.doc.updateOne(data);
  };

  findIdThenUpdate = async (id: string, data: T) => {
    const existingdata = await this.findById(id);
    await this.hook(HookType.beforeUpdate,data)
    try {
      Object.assign(data, User.getInstance().getUpdateFilter());
      Object.assign(existingdata, data);
      await this.validateData(data);
      let filter = this.getIsolationFilter();
      filter['_id'] = id;
      const result = await this.doc.findOneAndUpdate(filter, data);
      await this.hook(HookType.afterUpdate,data)
      return result;
    } catch (err) {
      throw new InternalServerErrorException(err.message);
    }
  };

  //find what foreign key constraint
  async getRelatedRecords(id: string) {
    const foreignkeysettings = foreignkeys[this.documentName];
    //console.log('foreignkeysettings', foreignkeysettings);
    const propkeys = Object.getOwnPropertyNames(foreignkeysettings);

    if (propkeys.length > 0) {
      //console.log('Have properties');
      for (let i = 0; i < propkeys.length; i++) {
        const collectionname = propkeys[i];
        //console.log('run ', i, collectionname);
        const fobjs = foreignkeysettings[propkeys[i]];
        const collection = this.doc.db.collection(collectionname);
        //single schema may have multiple foreign key link here, loop all
        for (let j = 0; j < fobjs.length; j++) {
          const fkey = fobjs[j] + '._id';
          const filter = {};
          filter[fkey] = id;
          //console.log('getRelatedRecords get filter', collectionname, filter);
          const result = await collection.findOne(filter);
          //console.log('getRelatedRecords', result);
          if (result) {
            return Promise.reject(result);
          }
        }
      }
    }
    return Promise.resolve(null);
  }
}
