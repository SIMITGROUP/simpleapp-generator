import { Injectable } from '@nestjs/common';
import { InjectModel } from '@nestjs/mongoose';
import { Model } from 'mongoose';
import Ajv from 'ajv';
import addFormats from 'ajv-formats';
import foreignkeys from '../dicts/foreignkeys.json';

import {
  NotFoundException,
  InternalServerErrorException,
} from '@nestjs/common/exceptions';
import { User } from './User';

export enum IsolationType {
  'org' = 'org',
  'tenant' = 'tenant',
  'branch' = 'branch',
}
@Injectable()
export class SimpleAppService<T extends { _id?: string }> {
  protected jsonschema = { type: 'object', properties: {}, required: [] };
  protected documentIdentityCode = 'code';
  protected documentIdentityName = 'label';
  protected documentName = 'category';
  protected documentType = 'CAT';
  protected LIMITPERPAGE = 20;
  protected isolationtype: IsolationType = IsolationType.org;
  protected isolationFilter: any = {};
  protected data: T = { _id: '' } as T;
  private doc: Model<T>; //set private to prevent developer break data isolation control
  protected errorlist = [];
  constructor(
    newdoc: Model<T>,
    isolationtype: IsolationType = IsolationType.org,
  ) {
    this.doc = newdoc;
    this.isolationtype = isolationtype;

    // this.tenantdoc = tenantdoc
  }
  getRecordId = (): string => this.data._id;
  setSchema = (newschema) => (this.jsonschema = newschema);
  getSchema = () => this.doc.schema.obj;
  getData = () => {
    //console.log('thisdata', this.data);
    return this.data;
  };
  setData = (newdata: T) => {
    delete newdata._id;
    this.data = { ...newdata };
    return this;
  };
  getIsolationFilter = () => {
    let isolationFilter = {};
    switch (this.isolationtype) {
      case 'branch':
        isolationFilter = User.getInstance().getBranchFilter();
        break;
      case 'tenant':
        isolationFilter = User.getInstance().getTenantFilter();
        break;
      case 'org':
      default:
        isolationFilter = User.getInstance().getOrgFilter();
        break;
    }
    return isolationFilter;
  };
  async list() {
    try {
      //console.log("this.isolationFilter",this.getIsolationFilter())
      const products = await this.doc.find(this.getIsolationFilter());
      // console.log(products)
      const productlist = products.map((p: T) => {
        return p;
      });
      //   console.log(products);
      return productlist;
    } catch (err) {
      throw new InternalServerErrorException(err.message);
    }
  }
  async getAutoComplete(keyword: string) {
    try {
      const filter1 = {};
      const filter2 = {};
      filter1[this.documentIdentityCode] = { $regex: keyword };
      filter2[this.documentIdentityName] = { $regex: keyword };
      const filterobj = { $or: [filter1, filter2] };

      Object.assign(filterobj, this.getIsolationFilter());
      const projections = {
        id: `\$_id`,
        label: `\$${this.documentIdentityCode}`,
        name: `\$${this.documentIdentityName}`,
      };
      const products = await this.doc.find(filterobj, projections, {
        limit: this.LIMITPERPAGE,
      });
      const productlist = products.map((p: T) => {
        return p;
      });
      return productlist;
    } catch (err) {
      throw new InternalServerErrorException(err.message);
    }
  }
  async search(filters: Object) {
    try {
      Object.assign(filters, this.getIsolationFilter());
      const products = await this.doc.find(filters);
      const productlist = products.map((p: T) => {
        return p;
      });
      //   console.log(products);
      return productlist;
    } catch (err) {
      throw new InternalServerErrorException(err.message);
    }
    // return this;
  }
  async findById(id: string) {
    const data = await this.search({ _id: id });
    if (data.length == 1) {
      // console.log('data0', data[0]);
      return data[0];
    } else {
      return null;
    }
  }

  async create() {
    let result;

    try {
      Object.assign(this.data, User.getInstance().getCreateFilter());
      delete this.data._id;
      this.validateData(this.data);      
      const newdoc = new this.doc(this.data);
      result = await newdoc.save();
    } catch (err) {
      throw new InternalServerErrorException(err.message);
    }
    return result as T;
  }
  async update() {
    const id: string = this.getRecordId();
    Object.assign(this.data, User.getInstance().getUpdateFilter());
    this.findIdThenUpdate(id, this.data);
  }
  async delete() {
    const id: string = this.getRecordId();
    const dependency = await this.getRelatedRecords(id);
    if (!dependency) {
      return await this.findIdThenDelete(id);
    } else {
      return dependency;
    }
  }
  hook(type: string, data: T) {
    return true;
  }
  validateData(data: T) {
    const ajv = new Ajv({ allErrors: true });
    addFormats(ajv);
    ajv.addFormat('x-document-no', /.*$/);
    ajv.addFormat('x-document-name', /.*$/);
    ajv.addFormat('x-text', /.*$/);
    ajv.addFormat('x-html', /.*$/);
    ajv.addKeyword({
      keyword: 'x-foreignkey',
      type: 'string',
    });

    if (!this.hook('pre-validation', data)) {
      const erromsg: string[] = [];
      for (let i = 0; i < this.errorlist.length; i++) {
        erromsg.push(this.errorlist[i].message);
      }
      console.log("pre-validation:",erromsg)
      throw new InternalServerErrorException(erromsg.join('\n'));
    }
    const validate = ajv.compile(this.jsonschema);
    const valid = validate(data);
    //console.log(validate.errors);
    if (!valid) {
      // console.log(validate.errors);
      const erromsg: string[] = [];
      for (let i = 0; i < validate.errors.length; i++) {
        erromsg.push(validate.errors[i].message);
      }
      console.log("ajv erromsg: ",erromsg)
      throw new InternalServerErrorException(erromsg.join('\n'));
    }
    this.hook('post-validation', data);
  }

  async findIdThenDelete(id: string): Promise<any> {
    // const data = await this.findById(id);
    try {
      //console.log('deletedeletedeletedelete');
      const dependency = await this.getRelatedRecords(id);
      if (!dependency) {
        let filter = this.getIsolationFilter();
        filter['_id'] = id;
        const deleteresult = await this.doc.deleteOne(filter);
        // this.doc.findByIdAndDelete(id)

        //this.doc.findByIdAndDelete(id);
        return deleteresult;
      } else {
        return Promise.reject(dependency);
      }
    } catch (err) {
      throw new InternalServerErrorException(err.message);
    }
  }

  updateOne = async (data: T) => {
    this.doc.updateOne(data);
  };

  findIdThenUpdate = async (id: string, data: T) => {
    const existingdata = await this.findById(id);

    try {
      Object.assign(data, User.getInstance().getUpdateFilter());
      Object.assign(existingdata, data);
      this.validateData(data);
      let filter = this.getIsolationFilter();
      filter['_id'] = id;
      const result = await this.doc.findOneAndUpdate(filter, data);

      return result;
    } catch (err) {
      throw new InternalServerErrorException(err.message);
    }
  };

  //find what foreign key constraint
  async getRelatedRecords(id: string) {
    const foreignkeysettings = foreignkeys[this.documentName];
    //console.log('foreignkeysettings', foreignkeysettings);
    const propkeys = Object.getOwnPropertyNames(foreignkeysettings);

    if (propkeys.length > 0) {
      //console.log('Have properties');
      for (let i = 0; i < propkeys.length; i++) {
        const collectionname = propkeys[i];
        //console.log('run ', i, collectionname);
        const fobjs = foreignkeysettings[propkeys[i]];
        const collection = this.doc.db.collection(collectionname);
        //single schema may have multiple foreign key link here, loop all
        for (let j = 0; j < fobjs.length; j++) {
          const fkey = fobjs[j];
          const filter = {};
          filter[fkey] = id;
          //console.log('getRelatedRecords get filter', collectionname, filter);
          const result = await collection.findOne(filter);
          //console.log('getRelatedRecords', result);
          if (result) {
            return Promise.reject(result);
          }
        }
      }
    }
    return Promise.resolve(null);
  }
}
