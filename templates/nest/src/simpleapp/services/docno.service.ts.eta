/**
 * This file was automatically generated by simpleapp generator.
 * It will not override by generator
 * last change 2023-09-23
 * Author: Ks Tan
 */
import { InjectModel } from '@nestjs/mongoose';
import { Model } from 'mongoose';
import { Injectable, InternalServerErrorException } from '@nestjs/common';
import { DocnoformatProcessor } from '../generate/processors/docno.processor';
import { Docnoformat } from '../generate/types/docno.type';
import { UserProfile } from '../generate/commons/user.profile';
import * as moment from 'moment';
export { Docnoformat } from '../generate/types/docno.type';

@Injectable()
export class DocnoformatService extends DocnoformatProcessor {
  constructor(@InjectModel('Docnoformat') mydoc: Model<Docnoformat>) {
    super(mydoc);
  }

  //    hook = async (type: string, data?: any) => {
  //     switch(type){
  //         case 'init':
  //         break;
  //         case 'beforeSearch':
  //         break;
  //         case 'afterSearch':
  //         break;
  //         case 'beforeValidation':
  //         break;
  //         case 'afterValidation':
  //         break;
  //         case 'beforeCreate':
  //         break;
  //         case 'afterCreate':
  //         break;
  //         case 'beforeUpdate':
  //         break;
  //         case 'afterUpdate':
  //         break;
  //         case 'beforeDelete':
  //         break;
  //         case 'afterDelete':
  //         break;
  //         case 'beforeFetchRecord':
  //         break;
  //         case 'afterFetchRecord':
  //         break;
  //         default:
  //         break;
  //         }
  //     return true;
  //   };

  /**
   * list document number format and prepare sample of docformat
   * @param appuser
   * @param doctype
   * @returns
   */
  async listDocFormats(appuser: UserProfile, doctype: string) {
    const searchresult = await this.search(appuser, { docNoType: doctype },{default:'desc'});
    console.log(searchresult);
    let data: any = [];
    for (let i = 0; i < searchresult.length; i++) {
      const s = searchresult[i];
      if (s.active) {
        const pattern = s.docNoPattern;
        const numberReg: RegExp = /\<(.*?)\>/g;
        const dateReg: RegExp = /\{(.*?)\}/g;
        let newvalue = pattern;
        const numberpattern: string[] = pattern.match(numberReg);
        const datepattern: string[] = pattern.match(dateReg);

        try {
          const numberlength = numberpattern[0]
            .replace('<', '')
            .replace('>', '').length;
          let nextnumber = s.nextNumber.toString();
          const numberdiff = numberlength - nextnumber.length;
          for (let n = 0; n < numberdiff; n++) {
            nextnumber = '0' + nextnumber;
          }
          for (let d = 0; d < datepattern.length; d++) {
            const dpattern = datepattern[d];
            const date = new Date();
            const formatteddate = moment().format(
              dpattern.replace('{', '').replace('}', ''),
            );
            newvalue = newvalue.replace(dpattern, formatteddate);
          }

          newvalue = newvalue.replace(numberpattern[0], nextnumber);

          data.push({
            _id: s._id,
            docNoFormatNo: s.docNoFormatNo,
            docNoFormatName: s.docNoFormatName,
            docNoPattern: s.docNoPattern,
            isMonthly: s.isMonthly,
            nextNumber: s.nextNumber,
            default:s.default,
            sample: newvalue,

          });
        } catch (e) {
          const errors = `Format ${s.docNoFormatName} error ${e}`;
          throw new InternalServerErrorException(errors);
        }
        console.log(
          'pattern',
          pattern,
          pattern.match(numberReg),
          pattern.match(dateReg),
          newvalue,
        );
      }
    }
    return data;
  }
}
