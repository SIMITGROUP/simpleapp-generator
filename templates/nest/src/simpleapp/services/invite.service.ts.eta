/**
 * This file was automatically generated by simpleapp generator.
 * It will not override by generator
 * last change 2023-09-23
 * Author: Ks Tan
 */
import _ from 'lodash'
import { InjectModel } from '@nestjs/mongoose';
import { Model, Schema,Types,PipelineStage } from 'mongoose';
import { BadRequestException, Injectable, InternalServerErrorException } from '@nestjs/common';
import { InvitationProcessor } from '../generate/processors/invite.processor';
import { Invitation } from '../generate/types/invite.type';
import { UserProfile } from '../generate/commons/user.profile';
import { PermissionService,Permission } from './perm.service';
import { UserService } from './user.service';
export { Invitation } from '../generate/types/invite.type';

@Injectable()
export class InvitationService extends InvitationProcessor {
  protected strictIsolation = false;
  constructor(
    @InjectModel('Invitation') mydoc: Model<Invitation>, 
    private readonly perm:PermissionService,
    private readonly usersvc:UserService
    ) {
    super(mydoc);
  }

     hook = async (appuser:UserProfile,type: string, data?: any) => {
      switch(type){
  //         case 'init':
  //         break;
  //         case 'beforeSearch':
  //         break;
  //         case 'afterSearch':
  //         break;
//          case 'beforeValidation':
            

  //        break;
  //         case 'afterValidation':
  //         break;
           case 'beforeCreate':

           const filterinvitation={email:data['email'], tenantId: appuser.getTenantId()}
            this.logger.warn("filterinvitation",filterinvitation)
            const existinginvitation = await this.search(appuser,filterinvitation)
            this.logger.warn("existinginvitation",existinginvitation)
            if (existinginvitation && existinginvitation.length>0){
              throw new BadRequestException(`user invitation ${data['email']} exists in tenant ${appuser.getTenantId()}`)
            }
            
            const searchresult = await this.usersvc.search(appuser,{email:data['email']})
            this.logger.warn("beforeCreate")            
            if (searchresult && searchresult.length>0){ //user exist in db, check permission exists              
              const u =Array.isArray(searchresult) ? searchresult[0] : searchresult
              //check user exist in current tenant
              const filterpermission={uid:u.uid,tenantId:appuser.getTenantId()}
              const existinguserpermission = await this.perm.search(appuser,filterpermission)

              if (existinguserpermission){
                throw new BadRequestException(`user permission ${u.uid} exists in tenant ${appuser.getTenantId()}`)
              }else{
                return true
              }
            }else { //user not exist in db, allow add
              return true
            }
           break;
  //         case 'afterCreate':
  //         break;
  //         case 'beforeUpdate':
  //         break;
  //         case 'afterUpdate':
  //         break;
  //         case 'beforeDelete':
  //         break;
  //         case 'afterDelete':
  //         break;
  //         case 'beforeFetchRecord':
  //         break;
  //         case 'afterFetchRecord':
  //         break;
  //         default:
  //         break;
          }
      return true;
    };


  
  /**
   * accept or reject invitation, and put user into permission table
   * @param appuser 
   * @param id 
   * @param decision 
   */
  async decideInvitation(appuser: UserProfile, id: string, decision: string) {
    
    const data = {  } as Invitation
    const o_id = new Types.ObjectId(id)
    const filteruser:PipelineStage = {$match:{_id:o_id}}
    const joinuserprofile:PipelineStage = {$lookup: {
      from:'user',
      localField:'email',
      foreignField:'email',
      as: 'user'
    }}
    const pipelinestages:PipelineStage[] = [filteruser,joinuserprofile]
    const aggresult = await this.aggregate(appuser,pipelinestages)
    
    console.log(aggresult)
    if(aggresult && aggresult.length>0){
      const existingdata= aggresult[0]
      
      if(appuser.getEmail() != existingdata.email){
        throw new BadRequestException(`invitation id ${id} only can accept by user with recipient email address`)
      }else if(!existingdata['user'] || existingdata['user'].length==0){
        throw new BadRequestException(`try to accept invitation id ${id} but user with email ${existingdata.email} does not exists`)
      }
      const userinfo = existingdata['user'][0]
      
      // findById(appuser, id);
      console.log("existingdata",existingdata)
      if(decision=='accept'){
        data.comment='done'    
        const permdata:Permission = {
          uid: userinfo.uid,
          orgId:1,
          branchId:1,
          tenantId:2,
          group:'cashier'
        }        
        this.perm.create(appuser,permdata)        
      }else{
        data.comment='reject'    
      }
      const props = existingdata._id    
      data.email = existingdata.email
      data.decision = decision  
      
      const result = await this.findIdThenUpdate(appuser,id, data);
      return "OK"
    }else{
      return "NG"
    }
    
    
  }
}
