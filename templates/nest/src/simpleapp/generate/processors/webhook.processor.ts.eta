/**
 * This file was automatically generated by simpleapp generator. Every
 * MODIFICATION OVERRIDE BY GENERATEOR
 * last change 2024-07-10
 * Author: Yong Xiang
 */
import { UserContext } from '../commons/user.context';
import * as sharelibs from '../sharelibs';
import { Injectable,  InternalServerErrorException, } from '@nestjs/common';
import { InjectModel } from '@nestjs/mongoose';
import jsonpath from 'jsonpath';
import { Model } from 'mongoose';
import { WebhookJsonSchema } from '../jsonschemas/webhook.jsonschema';
import { SimpleAppService } from './simpleapp.processor';
import * as types from '../types';
import { DocNumberFormatGenerator } from '../commons/docnogenerator.service';
import {
  WebhookBasicAuth,
  WebhookHeaders,
  Webhook,
} from '../types/webhook.type';
import {
  DefaultWebhookBasicAuth,
  DefaultWebhookHeaders,
  DefaultWebhook,
} from '../defaults/webhook.default';

@Injectable()
export class WebhookProcessor extends SimpleAppService<Webhook> {
  protected documentIdentityCode = 'title';
  protected documentIdentityLabel = 'title';
  private webhookApiKey = process.env.WEBHOOK_SERVER_APIKEY
  private webhookAppId=process.env.WEBHOOK_SERVER_APP_ID
  private webhookurl = process.env.WEBHOOK_SERVER_URL;
  private webhookprefix = process.env.PROJECT_CODE+'.'
  private  webhooksubscribtionurl = `${process.env.WEBHOOK_SERVER_URL}/subscriptions/`;

  protected hooks: types.WebhookHooks = {
    beforeCreate: async (appuser: UserContext, data: types.Webhook) =>
      this.beforeCreate(appuser, data),
    beforeUpdate: async (
      appuser: UserContext,
      id: string,
      prevdata: types.Webhook,
      newdata: types.Webhook,
    ) => this.beforeUpdate(appuser, id, prevdata, newdata),
    afterDelete: async (
      appuser: UserContext,
      result: types.DeleteResultType<types.Webhook>,
      id: string,
    ) => this.afterDelete(appuser, result, id),
  };


  protected foreignkeys = {};
  constructor(mydoc: Model<Webhook>) {
    super('WEBHOOK', 'webhook', mydoc, types.IsolationType.tenant);
    this.setSchema(WebhookJsonSchema);
    this.setData(DefaultWebhook(crypto.randomUUID()));
  }

  reCalculateValue(data: Webhook) {
    //console.log('trigger new recalculate')
    const $data = data;
  }

  async beforeCreate(appuser: UserContext, data: types.Webhook) {
    const createResult = await this.addRemoteWebhook(appuser, data);
    if (!createResult['subscription_id'])
      throw new InternalServerErrorException(
        'syncronize webhook server failed',
      );
    data.serverSubscriptionId = createResult.subscription_id;
    data.serverSubscriptionSecret = createResult.secret;
    // throw new BadRequestException("fail purposely")
  }

  async beforeUpdate(
    appuser: UserContext,
    id: string,
    prevdata: types.Webhook,
    newdata: types.Webhook,
  ) {

    if(!prevdata.serverSubscriptionId){
        const createResult = await this.addRemoteWebhook(appuser, newdata);
        if (!createResult['subscription_id'])
          throw new InternalServerErrorException(
            'syncronize webhook server failed',
           );
        newdata.serverSubscriptionId = createResult.subscription_id;
        newdata.serverSubscriptionSecret = createResult.secret;
    }else{
      await this.updateRemoteWebhook(appuser,newdata)
    }
  }

  async afterDelete(
    appuser: UserContext,
    result: types.DeleteResultType<types.Webhook>,
    id: string,
  ) {
    await this.removeRemoteWebhook(appuser,result,id)         
  }

  async removeRemoteWebhook(
    appuser: UserContext,
    result: types.DeleteResultType<types.Webhook>,
    id: string,
  ){
    const options = {
      method: 'DELETE',
      headers: {Authorization: this.webhookApiKey}
    };


    const subscriptionId=result.data.serverSubscriptionId
    if(!subscriptionId)return 

    try{
      const res = await fetch(
          `${this.webhooksubscribtionurl}/${subscriptionId}?application_id=${this.webhookAppId}`,
          options)            
    }catch(e){
      throw new InternalServerErrorException(e)
    }

  }
  async addRemoteWebhook(appuser: UserContext, data: types.Webhook) {
    const headers = {};
    data.headers.forEach((h) => {
      headers[h.name] = h.value;
    });

    const options = {
      method: 'POST',
      headers: {
        Authorization: this.webhookApiKey,
        accept: 'application/json',
        'content-type': 'application/json',
      },
      body: JSON.stringify({
        application_id: this.webhookAppId,
        description: data.title,
        metadata: {
          tenantId: data.tenantId.toString(),
          creator: appuser.getUname(),
        },
        is_enabled: data.active,
        event_types: data.eventTypes.map(
          (item) => this.webhookprefix + item,
        ),
        label_key: 'tenantId',
        label_value: data.tenantId.toString(),
        target: {
          headers: headers,
          type: 'http',
          method: data.requestMethod.toUpperCase(),
          url: data.url,
        },
      }),
    };
    try {
      const res = await fetch(this.webhooksubscribtionurl, options);
      return await res.json();
      if (res.status >= 300) {
        this.logger.error(res.statusText, 'create webhook failed');
        throw new InternalServerErrorException('create webhook failed');
      }
    } catch (e) {
      throw new InternalServerErrorException(e);
    }
  }

  async updateRemoteWebhook(appuser: UserContext, data: types.Webhook) {
    const headers = {};
    data.headers.forEach((h) => {
      headers[h.name] = h.value;
    });

    const options = {
      method: 'PUT',
      headers: {
        Authorization: this.webhookApiKey,
        accept: 'application/json',
        'content-type': 'application/json',
      },
      body: JSON.stringify({
        application_id: this.webhookAppId,
        description: data.title,
        metadata: {
          tenantId: data.tenantId.toString(),
          creator: appuser.getUname(),
        },
        is_enabled: data.active,
        event_types: data.eventTypes.map(
          (item) => this.webhookprefix + item,
        ),
        label_key: 'tenantId',
        label_value: data.tenantId.toString(),
        target: {
          headers: headers,
          type: 'http',
          method: data.requestMethod.toUpperCase(),
          url: data.url,
        },
      }),
    };
    try {
      const subscriptionId = data.serverSubscriptionId
      const res = await fetch(`${this.webhooksubscribtionurl}/${subscriptionId}`, options);
      return await res.json();
      if (res.status >= 300) {
        this.logger.error(res.statusText, 'updateRemoteWebhook webhook failed');
        throw new InternalServerErrorException('update webhook failed');
      }
    } catch (e) {
      throw new InternalServerErrorException(e);
    }
  }

  /***************************** additional execute *****************************************/
}
