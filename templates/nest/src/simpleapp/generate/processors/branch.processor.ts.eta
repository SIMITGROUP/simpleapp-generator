/**
 * This file was automatically generated by simpleapp generator. Every
 * MODIFICATION OVERRIDE BY GENERATEOR
 * last change 2024-07-10
 * Author: Yong Xiang
 */
import { UserContext } from '../commons/user.context';
import * as sharelibs from '../sharelibs';
import {
  Injectable,
  Inject,
  InternalServerErrorException,
} from '@nestjs/common';
import { InjectModel } from '@nestjs/mongoose';
import jsonpath from 'jsonpath';
import { Model } from 'mongoose';
import { BranchJsonSchema } from '../jsonschemas/branch.jsonschema';
import { SimpleAppService } from './simpleapp.processor';
import { IsolationType } from '../types';
import { DocNumberFormatGenerator } from '../commons/docnogenerator.service';
import { AutoincreamentService } from '../../services/autoinc.service';
import { alldocuments } from '../commons/dicts/documents';
import { Docnoformat, DocnoformatService } from '../../services/docno.service';
import { BranchOrganization, Branch, BranchHooks } from '../types/branch.type';
import {
  DefaultBranchOrganization,
  DefaultBranch,
} from '../defaults/branch.default';

@Injectable()
export class BranchProcessor extends SimpleAppService<Branch> {
  @Inject(AutoincreamentService)
  protected increament: AutoincreamentService;
  @Inject(DocnoformatService)
  private docnoservice: DocnoformatService;
  protected strictIsolation = false;
  protected documentIdentityCode = 'branchCode';
  protected documentIdentityLabel = 'branchName';
  protected hooks: BranchHooks = {
    beforeCreate: async (appuser: UserContext, data: Branch) =>
      await this.branchBeforeCreate(appuser, data),
    afterCreate: async (appuser: UserContext, data: Branch) =>
      await this.branchAfterCreate(appuser, data),
  };
  protected foreignkeys = { organization: ['$.organization._id'] };
  constructor(mydoc: Model<Branch>) {
    super('BRANCH', 'branch', mydoc, IsolationType.org);
    this.setSchema(BranchJsonSchema);
    this.setData(DefaultBranch(crypto.randomUUID()));
    this.addAutoCompleteField({
      branchId: 'branchId',
    });
  }

  reCalculateValue(data: Branch) {
    //console.log('trigger new recalculate')
  }

  /***************************** additional execute *****************************************/
  async branchBeforeCreate(appuser: UserContext, data: Branch) {
    const searchresult = await this.increament.runGenerateNextNo(
      appuser,
      'branch',
      'branchId',
    );
    data.branchId = searchresult.nextno;
  }
  async branchAfterCreate(appuser: UserContext, data: Branch) {
    await this.generateDefaultDocNumbers(appuser, data);
  }

  generateDefaultDocNumbers = async (appuser, data) => {
    const branchName = data.branchName;
    const branchCode = data.branchCode;
    const recordId = data._id;
    const branchId = data.branchId;
    const orgId = data.orgId;
    const tenantId = data.tenantId;
    const docformats = alldocuments.filter((item) => item.docNumber);
    for (let i = 0; i < docformats.length; i++) {
      const doc = docformats[i];
      const pattern = doc.docNoPattern.replace('@BranchCode',branchCode);
      const formatdata: Docnoformat = {
        _id: crypto.randomUUID(),
        docNoFormatNo: `${doc.docType}-${branchCode}`,
        docNoFormatName: `Default ${doc.docType} - ${branchCode}`,
        docNoType: doc.docType,
        docNoPattern: pattern,
        branch: { _id: recordId, branchId: branchId, label: branchName },
        branchId: branchId,
        orgId: orgId,
        tenantId: tenantId,
        nextNumber: 1,
      } as Docnoformat;
      try {
        const result = await this.docnoservice.create(appuser, formatdata);
        if (!result) {
          throw new InternalServerErrorException(
            `Generate default document number for "${branchCode}" failed. Pattern: ${pattern}`,
            'generateDefaultDocNumbers',
          );
        }
      } catch (err) {
        this.logger.error(err);
        throw new InternalServerErrorException(err);
      }
    }
  };
}
