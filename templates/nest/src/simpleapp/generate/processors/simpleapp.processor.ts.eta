/**
 * This file was automatically generated by simpleapp generator. Every
 * MODIFICATION OVERRIDE BY GENERATEOR
 * last change 2024-01-27
 * Author: Ks Tan
 */
import { Injectable, Logger, Inject } from '@nestjs/common';
import { InjectModel } from '@nestjs/mongoose';
import jsonpath from 'jsonpath';
import _ from 'lodash';

import { AuditTrail } from '../commons/audittrail.service';
import { foreignkeys } from '../commons/dicts/foreignkeys';
import { EventEmitter2 } from '@nestjs/event-emitter';
import {
  Model,
  Types,
  PipelineStage,
  mongo,
  FilterQuery,
  ProjectionType,
} from 'mongoose';
import Ajv from 'ajv';
import addFormats from 'ajv-formats';
import addErrors from 'ajv-errors';
import {
  NotFoundException,
  HttpException,
  BadRequestException,
  ForbiddenException,
  InternalServerErrorException,
  HttpExceptionOptions,
} from '@nestjs/common/exceptions';
import { UserContext } from '../commons/user.context';
import { CloudApiService } from 'src/cloudapi/cloudapi.service';
import { PrintApiService } from 'src/printapi/printapi.service';
import { DocNumberFormatGenerator } from '../commons/docnogenerator.service';
import {
  IsolationType,
  DefaultHooks,
  MoreProjectionType,
  DeleteResultType,
  WorkflowName,
  TextSearchBody,
} from '../types';
@Injectable()
export class SimpleAppService<T extends { _id?: string; __v?: number }> {
  @Inject(EventEmitter2)
  protected eventEmitter: EventEmitter2;
  @Inject(CloudApiService)
  protected cloudapi: CloudApiService;
  @Inject(PrintApiService)
  protected printapi: PrintApiService;
  protected hooks: DefaultHooks<T> = {};
  protected logger = new Logger();
  protected strictIsolation = true;
  protected jsonschema: any = {
    type: 'object',
    'x-simpleapp-config': {},
    properties: {},
    required: [],
  };
  protected documentIdentityCode = 'code';
  protected documentIdentityLabel = 'label';
  protected documentName = '-unknowndocname-';
  protected documentType = '-unknowndoctype-';
  protected LIMITPERPAGE = 20;
  protected moreAutoCompleteField: MoreProjectionType = {};
  protected isolationtype: IsolationType = IsolationType.org;
  protected isolationFilter: any = {};
  protected data: T = { _id: '' } as T;
  protected doc: Model<T>; //set private to prevent developer break data isolation control
  protected errorlist = [];
  protected withDocNumberFormat = false;
  protected foreignkeys = {};

  @Inject(AuditTrail)
  protected audittrail: AuditTrail;

  @Inject(DocNumberFormatGenerator)
  protected docnogenerator: DocNumberFormatGenerator;

  // protected userprovider = new UserContext() ;

  constructor(
    doctype: string,
    docname: string,
    newdoc: Model<T>,
    isolationtype: IsolationType = IsolationType.org,
  ) {
    // console.log("-------init simpleapp service abstract class -------userprovider=",typeof this.userprovider)
    this.documentType = doctype.toUpperCase();
    this.documentName = docname;
    this.doc = newdoc;

    this.isolationtype = isolationtype;
    if (this.hooks.init) this.hooks.init();
    // this.tenantdoc = tenantdoc
  }
  getDocumentType = () => this.documentType;
  getDocumentName = (capFirst: boolean = false) =>
    capFirst ? _.upperFirst(this.documentName) : this.documentName;
  getRecordId = (): string => this.data._id;
  setSchema = (newschema) => (this.jsonschema = newschema);
  getSchema = () => this.doc.schema.obj;
  getJsonSchema = () => this.jsonschema;
  getHooks = () => this.hooks;
  getData = () => {
    //console.log('thisdata', this.data);
    return this.data;
  };
  setData = (newdata: T) => {
    delete newdata._id;
    this.data = { ...newdata };
    return this;
  };
  public isReadOnly(): boolean {
    return false;
  }
  reCalculateValue(data: T) {}
  getIsolationFilter = (appuser: UserContext) => {
    let isolationFilter = {};
    switch (this.isolationtype) {
      case 'none':
        isolationFilter = {};
        break;
      case 'branch':
        isolationFilter = appuser.getBranchFilter();
        break;
      case 'tenant':
        isolationFilter = appuser.getTenantFilter();
        break;
      case 'org':
      default:
        isolationFilter = appuser.getOrgFilter();
        break;
    }
    return isolationFilter;
  };
  async list(appuser: UserContext) {
    try {
      //console.log("this.isolationFilter",this.getIsolationFilter())
      const products = await this.doc.find(this.getIsolationFilter(appuser));
      // console.log(products)
      const productlist = products.map((p: T) => {
        return p;
      });
      //   console.log(products);
      return productlist;
    } catch (err) {
      throw new InternalServerErrorException(err.message);
    }
  }
  addAutoCompleteField = (morefield: MoreProjectionType) => {
    const props = Object.getOwnPropertyNames(morefield);
    // console.log('addAutoCompleteField', props);
    for (let i = 0; i < props.length; i++) {
      const key = props[i];
      this.moreAutoCompleteField[key] = '$' + morefield[key];
    }
    // console.log(this.moreAutoCompleteField);
  };
  async getAutoComplete(appuser: UserContext, keyword: string, data?: T) {
    try {
      const filter1 = {};
      const filter2 = {};
      let filters: any[] = [];
      if (
        this.jsonschema.properties[this.documentIdentityCode]['type'] ==
        'string'
      ) {
        filter1[this.documentIdentityCode] = { $regex: keyword, $options: 'i' };
        filters.push(filter1);
      }
      filter2[this.documentIdentityLabel] = { $regex: keyword, $options: 'i' };
      filters.push(filter2);

      const filterobj = { $or: filters };
      Object.assign(filterobj, data);
      Object.assign(filterobj, this.getIsolationFilter(appuser));
      let projections = {
        label: `\$${this.documentIdentityLabel}`,
        code: `\$${this.documentIdentityCode}`,
      };
      if (this.moreAutoCompleteField) {
        Object.assign(projections, this.moreAutoCompleteField);
      }
      const products = await this.doc.find(filterobj, projections, {
        limit: this.LIMITPERPAGE,
      });
      const productlist = products.map((p: T) => {
        return p;
      });
      return productlist;
    } catch (err) {
      throw new InternalServerErrorException(err.message);
    }
  }

  /**
   * Special search function which can by pass data isolation. reserved and try not use
   * @param appuser
   * @param filters
   * @returns
   */
  private async searchNoIsolation(
    appuser: UserContext,
    filters: FilterQuery<T>,
  ) {
    try {
      if (this.hooks.beforeSearch)
        await this.hooks.beforeSearch(appuser, filters);
      const products = await this.doc.find(filters);
      const productlist = products.map((p) => {
        return p;
      });
      if (this.hooks.afterSearch)
        await this.hooks.afterSearch(appuser, productlist);

      //   console.log(products);
      return productlist;
    } catch (err) {
      throw new InternalServerErrorException(err.message);
    }
    // return this;
  }
  async aggregate(appuser: UserContext, pipeline: PipelineStage[]) {
    if (pipeline[0] && pipeline[0]['$match']) {
      try {
        const isolationFilter = { ...this.getIsolationFilter(appuser) };
        this.polishIsolationFilter(isolationFilter);

        Object.assign(pipeline[0]['$match'], isolationFilter);
        this.logger.verbose(pipeline, `${this.documentName} aggregate:`);
        return await this.doc.aggregate(pipeline, {
          session: appuser.getDBSession(),
        });
      } catch (err) {
        throw new InternalServerErrorException(err);
      }
    } else {
      throw new InternalServerErrorException(
        'first aggregate pipelinestage shall use $match',
      );
    }
  }
  async search(
    appuser: UserContext,
    filters: FilterQuery<T>,
    projection: string[] = undefined,
    sort: any = undefined,
    lookup: { [key: string]: string } = undefined,
  ) {
    try {
      const isolationFilter = { ...this.getIsolationFilter(appuser) };
      this.polishIsolationFilter(isolationFilter);

      // console.log("initial search",filters)
      const newfilters: FilterQuery<T> = { ...filters, ...isolationFilter };

      if (this.hooks.beforeSearch)
        await this.hooks.beforeSearch(appuser, newfilters);
      // console.log("before _find",newfilters)
      // console.log("this.doc",this.doc)
      let searchResults: T[] = [];
      if (lookup === undefined) {
        this.logger.debug('after search', newfilters);
        searchResults = await this.doc
          .find(newfilters, projection, { session: appuser.getDBSession() })
          .sort(sort);
      } else {
        const pipelines = this.searchToAggregate(
          appuser,
          filters,
          projection,
          sort,
          lookup,
        );
        this.logger.debug('after aggregate', pipelines);

        searchResults = await this.aggregate(appuser, pipelines);
      }

      const list: T[] = searchResults.map((p: T) => {
        return p;
      });
      // console.log("after map",productlist)
      if (this.hooks.afterSearch) await this.hooks.afterSearch(appuser, list);

      //   console.log(products);
      return list;
    } catch (err) {
      throw new BadRequestException(err.message);
    }
    // return this;
  }

  async fullTextSearch(appuser: UserContext, body: TextSearchBody) {
    const isolationFilter = { ...this.getIsolationFilter(appuser) };
    this.polishIsolationFilter(isolationFilter);

    const filters = { $text: { $search: body.keyword } };
    const newfilters: FilterQuery<T> = { ...filters, ...isolationFilter };
    const fields = body.fields;
    const sorts = body.sorts;
    //not yet support lookup mapper
    const lookup = body.lookup;
    return await this.doc.find(newfilters, fields, sorts);
  }
  async findById(appuser: UserContext, id: string) {
    if (this.hooks.beforeFetchRecord)
      await this.hooks.beforeFetchRecord(appuser, id);

    const data = await this.search(appuser, { _id: id as any });
    if (this.hooks.afterFetchRecord)
      await this.hooks.afterFetchRecord(appuser, data[0]);

    if (data.length == 1) {
      // console.log('data0', data[0]);
      return data[0];
    } else {
      return null;
    }
  }

  /**
   * create many from array, for performance reason it submit all item in 1 go, so it won't implement hooks
   * @param appuser
   * @param datas
   */
  async createMany(appuser: UserContext, datas: T[]) {
    if (Array.isArray(datas)) {
      for (let i = 0; i < datas.length; i++) {
        const data = datas[i];
        let isolationFilter: any = { ...appuser.getCreateFilter() };
        isolationFilter = this.polishIsolationFilter(isolationFilter, data);

        Object.assign(data, isolationFilter);
        this.reCalculateValue(data);
        await this.validateData(appuser, data);
        this.applyNestedDateTime(appuser, data, 'create');
      }

      const result = await this.doc.insertMany(datas);
      await this.audittrail.addManyEvents(
        appuser,
        this.documentName,
        'createMany',
        datas,
      );
      return result;
    } else {
      throw new BadRequestException(
        this.getDocumentType() + ': create many only support array',
      );
    }
  }

  async create(appuser: UserContext, data: T) {
    let result;

    if (!data._id) {
      data._id = crypto.randomUUID();
    }
    const dbsession = appuser.getDBSession();
    if (dbsession && !dbsession.inTransaction()) {
      dbsession.startTransaction();
    }

    this.logger.debug(
      'this.withDocNumberFormat :' +
        this.withDocNumberFormat +
        '  && ' +
        '!data[this.documentIdentityCode] ==' +
        !data[this.documentIdentityCode],
    );
    if (this.withDocNumberFormat && !data[this.documentIdentityCode]) {
      await this.genNewDocNo(appuser, data);
    }

    let isolationFilter: any = { ...appuser.getCreateFilter() };
    isolationFilter = this.polishIsolationFilter(isolationFilter, data);

    this.logger.debug('isolationFilter', 'SimpleAppService');
    this.logger.debug(isolationFilter, 'SimpleAppService');
    this.logger.debug('Create data before isolation', 'SimpleAppService');
    this.logger.debug(data, 'SimpleAppService');
    Object.assign(data, isolationFilter);
    this.reCalculateValue(data);
    await this.validateData(appuser, data);
    this.logger.debug(data, `after create validation`);
    this.applyNestedDateTime(appuser, data, 'create');

    if (this.hooks.beforeCreate) await this.hooks.beforeCreate(appuser, data);
    this.logger.debug(data, `Create Record ${this.documentName}`);
    const newdoc = new this.doc(data);
    await this.identifyForeignKeys(appuser, data);
    try {
      result = await newdoc.save({ session: dbsession });
      await this.audittrail.addEvent(
        appuser,
        this.documentName,
        result._id,
        'create',
        data,
      );
      appuser.addInsertedRecordId(this.documentName, result._id);
    } catch (err) {
      this.logger.error(err);
      throw new InternalServerErrorException(err);
    }

    // this.doc.create(data)
    // this.doc

    // result = await newdoc.save()
    try {
      if (this.hooks.afterCreate) await this.hooks.afterCreate(appuser, result);
      this.callWebhook(appuser, 'create', result);
      return result as T;
    } catch (err) {
      throw new InternalServerErrorException(
        `createHook ${this.documentType} error: ${JSON.stringify(err)}`,
        `${this.documentType} createHook error`,
      );
    }
  }

  applyNestedDateTime = (
    appuser: UserContext,
    data: any,
    transtype: string,
  ) => {
    const props = Object.getOwnPropertyNames(data);
    for (let i = 0; i < props.length; i++) {
      const key = props[i];
      //need to apply nested
      if (
        Array.isArray(data[key]) &&
        data[key].length > 0 &&
        typeof data[key][0] == 'object'
      ) {
        for (let j = 0; j < data[key].length; j++) {
          this.applyNestedDateTime(appuser, data[key][j], transtype);
        }
      } else if (key == 'created') {
        data['created'] =
          transtype == 'create' || !data['created']
            ? new Date().toISOString()
            : data['created'];
      } else if (key == 'createdBy') {
        data['createdBy'] =
          transtype == 'create' || !data['createdBy']
            ? appuser.getUid()
            : data['createdBy'];
      } else if (key == 'updated') {
        data['updated'] = new Date().toISOString();
      } else if (key == 'updatedBy') {
        data['updatedBy'] = appuser.getUid();
      }
    }
  };
  async validateData(appuser: UserContext, data: T, _id?: string) {
    const ajv = new Ajv({ allErrors: true, useDefaults: true });
    addFormats(ajv);
    addErrors(ajv);

    ajv.addFormat('tel', /^$|^\d{7,15}$/gm);
    ajv.addFormat('text', /.*$/);
    ajv.addFormat('html', /.*$/);
    ajv.addFormat('documentno', /.*$/);
    ajv.addFormat('money', /.*$/);

    ajv.addKeyword({ keyword: 'x-foreignkey', schemaType: 'string' });
    ajv.addKeyword({ keyword: 'x-simpleapp-config', schemaType: 'object' });
    this.logger.debug('run hook during validation');
    let issuccess = true;
    if (this.hooks.beforeValidation) {
      issuccess = await this.hooks.beforeValidation(appuser, data, _id);
    }
    // const issuccess = await this.hook(appuser, HookType.beforeValidation, data);
    if (!issuccess) {
      const errormsg: string[] = [];
      for (let i = 0; i < this.errorlist.length; i++) {
        errormsg.push(this.errorlist[i].message);
      }

      throw new BadRequestException(
        'Before validation hook failed',
        errormsg as HttpExceptionOptions,
      );
    }

    let validate;
    try {
      validate = ajv.compile(this.jsonschema);
    } catch (err) {
      this.logger.error('compile error', err);
      throw new ForbiddenException(err.message);
    }
    const valid = validate(data);
    if (!valid) {
      this.logger.error(JSON.stringify(validate.errors), 'validate errors:');
      throw new BadRequestException(
        'Data validation failed',
        validate.errors as HttpExceptionOptions,
      );
    }
    if (this.hooks.afterValidation)
      await this.hooks.afterValidation(appuser, data, _id);
  }

  polishIsolationFilter = (filterIsolation: any, data: any = {}) => {
    if (this.isolationtype == 'none') {
      delete filterIsolation['branchId'];
      delete filterIsolation['orgId'];
      delete filterIsolation['tenantId'];
    }
    if (this.isolationtype == 'tenant' && !this.strictIsolation) {
      // delete filterIsolation['tenantId']
      if (data['tenantId']) {
        filterIsolation['tenantId'] = data['tenantId'];
      }
      delete filterIsolation['branchId'];
      delete filterIsolation['orgId'];
    }
    if (this.isolationtype == 'org' && !this.strictIsolation) {
      // delete filterIsolation['tenantId']
      if (data['tenantId']) {
        filterIsolation['tenantId'] = data['tenantId'];
      }
      if (data['orgId']) {
        filterIsolation['orgId'] = data['orgId'];
      }
      // delete filterIsolation['orgId']
      delete filterIsolation['branchId'];
    }
    return filterIsolation;
  };
  async findIdThenDelete(appuser: UserContext, id: string): Promise<any> {
    const deletedata = await this.findById(appuser, id);
    if (!deletedata) {
      throw new NotFoundException(`${id} not found`, 'not found');
    }
    const dbsession = appuser.getDBSession();
    if (dbsession && !dbsession.inTransaction()) {
      dbsession.startTransaction();
    }

    let dependency;
    try {
      if (this.hooks.beforeDelete)
        await this.hooks.beforeDelete(appuser, id, deletedata);
      this.logger.debug('delete record', this.documentName, id);
      dependency = await this.getRelatedRecords(appuser, id);
      //console.log('dependency', dependency);
      if (!dependency) {
        let filterIsolation = this.getIsolationFilter(appuser);
        this.polishIsolationFilter(filterIsolation);

        filterIsolation['_id'] = id;
        this.logger.debug('delete filter', filterIsolation);
        const result = await this.doc
          .deleteOne(filterIsolation)
          .session(dbsession);
        await this.audittrail.addEvent(
          appuser,
          this.documentName,
          id,
          'delete',
          deletedata,
        );

        appuser.addDeletedRecordId(this.documentName, id);
        const deleteresult: DeleteResultType<T> = {
          result: result,
          data: deletedata,
        };
        this.logger.debug(
          deleteresult,
          ' delete result' + this.doc.collection.name,
        );
        // this.doc.findByIdAndDelete(id)

        if (this.hooks.afterDelete)
          await this.hooks.afterDelete(appuser, deleteresult, id);
        //this.doc.findByIdAndDelete(id);
        this.callWebhook(appuser, 'delete', deletedata);
        return deleteresult;
      } else {
        this.logger.debug('reject query', dependency);

        throw new ForbiddenException(dependency, 'Foreignkey constraint');
      }
    } catch (err) {
      throw new InternalServerErrorException(err);
      //JSON.stringify(dependency),JSON.stringify(dependency)
    }
  }

  // updateOne = async (appuser:UserContext,data: T) => {
  //   this.doc.updateOne(data);
  // };

  findIdThenUpdate = async (appuser: UserContext, id: string, data: T) => {
    try {
      //version exists, need ensure different only 1
      const existingdata = await this.findById(appuser, id);
      if (!existingdata)
        throw new NotFoundException(
          `${this.documentName} findIdThenUpdate:  _id:${id} not found`,
          'not found',
        );

      this.logger.debug(
        'update id:' + id,
        this.documentName + ' findIdThenUpdate',
      );
      if (typeof data.__v == 'number' && data.__v != existingdata.__v) {
        throw new BadRequestException(
          `You submit older version data "v${data.__v}"" but latest version = "v${existingdata.__v}"`,
        );
      }
      // this.logger.debug('warn1', existingdata);
      data.__v = existingdata.__v + 1;
      // if (!existingdata) {
      //   throw new NotFoundException(`${id} not found`, 'not found');
      // }
      // this.logger.debug('warn2');
      if (this.hooks.beforeUpdate)
        await this.hooks.beforeUpdate(appuser, id, existingdata, data);

      const dbsession = appuser.getDBSession();
      if (dbsession && !dbsession.inTransaction()) {
        dbsession.startTransaction();
      }
      // try {
      Object.assign(data, appuser.getUpdateFilter());
      // Object.assign(existingdata, data);

      delete data['_id'];
      this.reCalculateValue(data);

      // existingdata['_id']=''
      await this.validateData(appuser, data, id);

      const isolationFilter = { ...this.getIsolationFilter(appuser) };
      this.polishIsolationFilter(isolationFilter);
      isolationFilter['_id'] = id;
      this.applyNestedDateTime(appuser, data, 'update');

      const result = await this.doc.findOneAndReplace(isolationFilter, data, {
        session: dbsession,
        new: true,
      });
      await this.audittrail.addEvent(
        appuser,
        this.documentName,
        id,
        'update',
        data,
      );

      appuser.addUpdatedRecordId(this.documentName, data._id);
      if (this.hooks.afterUpdate)
        await this.hooks.afterUpdate(appuser, id, existingdata, result);
      this.callWebhook(appuser, 'update', result);
      return result; // await this.findById(appuser, id);
    } catch (err) {
      this.logger.error(err);
      throw new InternalServerErrorException(err.message);
    }
  };

  findIdThenPatch = async (
    appuser: UserContext,
    id: string,
    data: T,
    session: mongo.ClientSession = undefined,
  ) => {
    const existingdata = await this.findById(appuser, id);
    if (!existingdata) {
      throw new NotFoundException(`${id} not found`, 'not found');
    }
    if (typeof data.__v == 'number' && data.__v != existingdata.__v) {
      throw new BadRequestException(
        `You submit older version data "v${data.__v}"" but latest version = "v${existingdata.__v}"`,
      );
    }

    data.__v = existingdata.__v + 1;

    if (this.hooks.beforeUpdate)
      await this.hooks.beforeUpdate(appuser, id, existingdata, data);

    const dbsession = appuser.getDBSession();
    if (dbsession && !dbsession.inTransaction()) {
      dbsession.startTransaction();
    }
    // try {
    Object.assign(data, appuser.getUpdateFilter());
    // Object.assign(existingdata, data);
    delete data['_id'];

    this.reCalculateValue(data);

    // existingdata['_id']=''
    // console.log("newdata",data)
    //path record no validation
    // await this.validateData(appuser, data);

    const isolationFilter = { ...this.getIsolationFilter(appuser) };
    this.polishIsolationFilter(isolationFilter);

    isolationFilter['_id'] = id;
    this.applyNestedDateTime(appuser, data, 'update');

    try {
      const result = await this.doc.findOneAndUpdate(isolationFilter, data, {
        session: dbsession,
        new: true,
      });
      await this.audittrail.addEvent(
        appuser,
        this.documentName,
        id,
        'patch',
        data,
      );
      appuser.addUpdatedRecordId(this.documentName, data._id);

      if (this.hooks.afterUpdate)
        await this.hooks.afterUpdate(appuser, id, existingdata, result);
      this.callWebhook(appuser, 'update', result);
      return result; //await this.findById(appuser, id);
    } catch (err) {
      throw new InternalServerErrorException(err.message);
    }
  };

  //find what foreign key constraint
  async getRelatedRecords(appuser: UserContext, id: string) {
    this.logger.debug('get foreignkey for delete:', id);
    // console.log('session modifeds', appuser.getModifieds());
    if (foreignkeys === undefined) {
      this.logger.error('foreignkeys object undetected');
      throw new InternalServerErrorException('foreignkeys object undetected');
    }

    const foreignkeysettings = foreignkeys[this.documentName];
    if (!foreignkeysettings) {
      return null;
    }
    const propkeys = Object.getOwnPropertyNames(foreignkeysettings);

    if (propkeys.length > 0) {
      //console.log('Have properties');
      for (let i = 0; i < propkeys.length; i++) {
        const collectionname = propkeys[i];
        //console.log('run ', i, collectionname);
        const fobjs = foreignkeysettings[propkeys[i]];
        const collection = this.doc.db.collection(collectionname);
        //single schema may have multiple foreign key link here, loop all
        for (let j = 0; j < fobjs.length; j++) {
          const fkey = fobjs[j];
          //not deleted in current session, check from database
          let filter = {};
          filter[fkey] = id;
          const result = await collection.findOne(filter, {
            session: appuser.getDBSession(),
          });
          if (result) {
            this.logger.error(result, 'related result found');
            return result;
          }
        }
      }
    }
    return null;
  }

  /**
   * dummy ping
   */
  ping(...data) {
    return `hello ${JSON.stringify(data)}`;
  }

  /**
   * change property documentStatus for specific document, no workflow execution
   * @param id
   * @param data optional document
   * @param docstatus
   * @returns Promise
   */
  async setDocumentStatus(
    appuser: UserContext,
    id: string,
    data: T,
    docstatus: string,
  ) {
    id = id.trim();

    if (!id) {
      throw new BadRequestException(
        'undefined path para "id"',
        'undefined "id"',
      );
    }
    if (data['_id'] && data['_id'] != id) {
      throw new BadRequestException(
        `_id in data(${data['_id']} different with path param ${id})`,
        'set documentstatus id not match with submited data',
      );
    }
    const existdata = await this.findById(appuser, id);
    if (existdata && existdata['documentStatus'] == docstatus) {
      throw new BadRequestException(
        `Same document status "${docstatus}" is not allowed`,
      );
    }
    data['documentStatus'] = docstatus;
    // await this.hook(appuser, HookType.beforeSetStatus, data);
    if (this.hooks.beforeSetStatus)
      await this.hooks.beforeSetStatus(appuser, docstatus, data, existdata);

    if (data && !data['created']) {
      const createresult = await this.create(appuser, data);
      if (this.hooks.afterSetStatus)
        await this.hooks.afterSetStatus(appuser, docstatus, createresult);
      await this.audittrail.addEvent(
        appuser,
        this.documentName,
        id,
        docstatus,
        data,
      );

      return createresult;
    } else {
      const updateresult = await this.findIdThenPatch(appuser, id, data);
      const finaldata = await this.findById(appuser, id);
      if (this.hooks.afterSetStatus)
        await this.hooks.afterSetStatus(appuser, docstatus, finaldata);
      await this.audittrail.addEvent(
        appuser,
        this.documentName,
        id,
        docstatus,
        data,
      );

      this.callWebhook(appuser, docstatus, finaldata);
      return updateresult;
    }
  }

  /**
   * similar like runWorker, but it is syncronizely add event into queue and return.
   * No result will return from this method,  it also lose appuser db's transaction
   * due out of request flow
   *
   * @param      {UserContext}  appuser    The appuser
   * @param      {string}       eventName  The event name
   * @param      {any}          data       The data
   */
  runBackgroundWorker(appuser: UserContext, eventName: string, payloads: any) {
    this.eventEmitter.emit(eventName, appuser, payloads);
  }

  /**
   * runWorker design with 2 purpose
   *   1. we wish developer develop complex programming flow in worker class instead
   *      of service class. We wish service class remain simple and easy to understand
   *      it wish to do hook and api only
   *      complex task service class may pass to worker class.
   *   2. it not cause circulate injection hell, which is useful in complex dependency
   * this run foreground event which can async/await to obtain execution result,
   * the appuser dbtransaction remain usable. however, the execution may delay response
   *
   *
   * @param      {UserContext}  appuser    The appuser
   * @param      {string}       eventName  The event name
   * @param      {any}          data       The data
   * @return     {Promise}      { description_of_the_return_value }
   */
  async runWorker(appuser: UserContext, eventName: string, payloads: any) {
    const res = await this.eventEmitter.emitAsync(eventName, appuser, payloads);
    if (!this.eventEmitter.hasListeners(eventName)) {
      throw new InternalServerErrorException(`${eventName} seems no listener`);
    }
    if (!res) {
      throw new InternalServerErrorException(`${eventName} is invalid worker`);
    }

    const result = res[0];
    if (result?.name && result?.name.includes('Exception')) throw result;
    return result;
  }
  startWorkflow(
    appuser: UserContext,
    processName: WorkflowName,
    workflowData: any,
  ) {
    return this.eventEmitter.emit(
      'workflow.start',
      appuser,
      processName,
      workflowData,
    );
  }

  async genNewDocNo(appuser: UserContext, data: T) {
    this.logger.debug('genNewDocNo');
    const result = await this.docnogenerator.generateNextNumberFromDocument(
      appuser,
      this.documentType,
      data,
    );
    this.logger.debug(result, 'genNewDocNo');
    data[this.documentIdentityCode] = result;
  }
  async runDefault(appuser: UserContext): Promise<unknown> {
    return (
      'Hello this is ' + this.getDocumentType() + ': ' + this.getDocumentName()
    );
  }
  async identifyForeignKeys(appuser: UserContext, data: T) {
    /**
     * 1. looping schemas identify what foreign key exists
     * 2. loop through record obtain all foreign key value
     * 3. get all unique key value in array {product:['xxxx','yyyy'],customer:['aaa']}
     */
    const schema = this.jsonschema;

    //get all foreign keys catalogue
    const collections = Object.getOwnPropertyNames(this.foreignkeys);

    //obtain exists data in according foreign key
    const pipelines: PipelineStage[] = [{ $match: { _id: false } }]; //exclude data from current collection
    const vdata = data; //['_doc']
    const keystore = {};
    collections.forEach((collectionname) => {
      const fks: string[] = this.foreignkeys[collectionname];
      let results: string[] = [];
      fks.forEach((fieldpath) => {
        //console.log("fieldpath:",fieldpath,"vdata",data,vdata)
        const tmp = jsonpath
          .query(vdata, fieldpath)
          .filter((item: string) => item != '');
        // console.log("tmp",tmp)

        results = results.concat(tmp);
      });

      if (results.length > 0) {
        if (results.length > 1) {
          results = _.uniq<string>(results);
        }

        keystore[collectionname] = results;
        //console.log("keystorekeystore",keystore)
        let addfield = { $addFields: { collection: collectionname } };

        const stagefilter: PipelineStage = {
          $unionWith: {
            coll: collectionname,
            pipeline: [
              { $match: { _id: { $in: results } } },
              addfield,
              { $project: { collection: 1 } },
            ],
          },
        };
        pipelines.push(stagefilter);
      }
    });
    this.logger.debug(pipelines, 'identifyForeignKeys pipelines');
    // this.doc.db.collection(collectionname);
    const unionresult = await this.doc.aggregate(pipelines);

    if (!unionresult) {
      this.logger.error('foreign key control failed ', 'identifyForeignKeys');
      throw new InternalServerErrorException(
        'Foreignkey check execution error',
        pipelines as HttpExceptionOptions,
      );
    } else {
      let searchresult: any = {};
      unionresult.forEach((item) => {
        if (searchresult[item.collection]) {
          searchresult[item.collection].push(item._id);
        } else {
          searchresult[item.collection] = [item._id];
        }
      });
      this.logger.debug(unionresult, this.documentType + ' search Result');

      //search is it all foreign key exists in db
      for (let i = 0; i < collections.length; i++) {
        const collectionname = collections[i];
        const keys: string[] = keystore[collectionname];
        if (!keys) {
          continue;
        }
        for (let k = 0; k < keys.length; k++) {
          const key = keys[k];
          if (
            searchresult[collectionname] &&
            searchresult[collectionname].includes(key)
          ) {
            this.logger.debug(`foreignkey ${collectionname}->${key} exists`);
          } else if (appuser.searchInsertedRecordId(collectionname, key)) {
            this.logger.debug(
              `foreignkey ${collectionname} exists in user context which not yet commited`,
            );
          } else {
            this.logger.warn(
              `${this.documentType}: Foreignkey ${key} at collection ${collectionname} does not exist`,
              'identifyForeignKeys',
            );
            this.logger.debug(appuser.getModifieds, 'appuser.getModifieds');
            const errordata = { key: key, collection: collectionname };
            throw new BadRequestException(
              `${this.documentType}: Foreignkey ${key} at collection ${collectionname} does not exist`,
              JSON.stringify(errordata),
            );
          }
        }
      }
    }
  }

  async print(appuser: UserContext, id: string, formatid: string) {
    const pdfresult = await this.printapi.getBase64Pdf(appuser, formatid, id);
    return pdfresult;
  }

  searchToAggregate(
    appuser: UserContext,
    filter: FilterQuery<T>,
    columns: string[],
    sort: string[][],
    lookup: { [key: string]: string },
  ) {
    const pipelines: PipelineStage[] = [];
    const projection = {};
    // console.log('sortsort', sort);

    pipelines.push({ $match: filter });
    if (Array.isArray(columns) && columns.length > 0) {
      columns.forEach((col) => {
        projection[col] = 1;
      });
    }

    const collections = Object.keys(lookup);
    collections.forEach((tokey: string) => {
      const toarr = tokey.split('.');
      const to = toarr[0];
      toarr.splice(0,1)
      const foreignField = toarr.join('.') ?? '_id';
      pipelines.push({
        $lookup: {
          from: to,
          as: '_' + to,
          localField: lookup[tokey],
          foreignField: foreignField,
          pipeline: [{ $match: { tenantId: appuser.getTenantId() } }],
        },
      });
      pipelines.push({ $unwind: '$_' + to });

      if (Object.keys(projection).length > 0) projection['_' + to] = 1;
    });

    if (Object.keys(projection).length > 0)
      pipelines.push({ $project: projection });

    if (Array.isArray(sort) && sort.length > 0) {
      const sortobj = {};
      sort.forEach((item) => {
        sortobj[item[0]] = item[1].toLowerCase() == 'asc' ? 1 : -1;
      });
      pipelines.push({ $sort: sortobj });
    }
    //this.logger.warn( pipelines,'pipelinespipelinespipelines',);

    return pipelines;
  }

  callWebhook(appuser: UserContext, actionName: string, data: any) {
    this.eventEmitter.emit(
      'webhook',
      appuser,
      this.documentName,
      actionName,
      data,
    );
  }
}
