/**
 * This file was automatically generated by simpleapp generator. Every
 * MODIFICATION OVERRIDE BY GENERATEOR
 * last change 2023-10-28
 * Author: Ks Tan
 */
// import { UserContext } from './user.context';
import { InjectModel } from '@nestjs/mongoose';
import { Model } from 'mongoose';
import { Tenant } from '../../types';
const Base64URL = require('@darkwolf/base64url');
// import { Docnoformat } from '../types/docno.type';
import {
  Injectable,
  InternalServerErrorException,
  BadRequestException,
} from '@nestjs/common';
// import moment from 'moment';
import dayjs from 'dayjs';
// import { ForeignKey } from '../types';

export class ApiKeyService {
  constructor(@InjectModel('Tenant') private tenant: Model<Tenant>) {}

  async verifyTenantId(req: Request) {
    const xapikey = req.headers['x-api-key'];
    const xapisecret = req.headers['x-api-secret'];
    const xorg = req.headers['x-org'];

    if (
      xapikey == process.env.X_API_KEY &&
      xapisecret == process.env.X_API_SECRET
    ) {
      return true;
    }

    try {
      const decodedText: string = Base64URL.decodeText(xorg);
      const x = decodedText.includes('/')
        ? decodedText.split('/')
        : decodedText.split('-');

      const tenantId = Number(x[0]);

      const tenant = await this.tenant.findOne({
        tenantId: tenantId,
        active: true,
      });

      console.log("tenant",tenant)
      if (!tenant) {
        
        return false
        // throw new BadRequestException('apikey verification error,unknown tenant or tenant is inactive');
      }

      const indexofkey = tenant.apiKeys.findIndex((item) => {
        if (item.apiKey == xapikey && item.apiSecret == xapisecret) {
          return true;
        }
      });      
      return indexofkey!= -1     
    } catch (e) {
      console.log('error in verifyTenantId', e);
      throw new BadRequestException('Invalid API Key');
    }
  }
}
