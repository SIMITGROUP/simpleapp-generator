import { Injectable, Scope,Inject } from '@nestjs/common';

import { Model,model,connect } from 'mongoose';
import _ from 'lodash'
import { Module } from '@nestjs/common';
import * as jwt from 'jsonwebtoken';
import { Role } from '../roles/roles.enum';
import * as rolegroups from '../roles/roles.group'
import { UserService } from '../../../services/user.service';
import { InjectModel } from '@nestjs/mongoose';
const Base64URL = require('@darkwolf/base64url');
import { UserMongoSchema } from '../../models/user.model';
import {  UserBranchesBranch,  UserBranches,  User,  }  from '../../types/user.type';


export const UserProviderFactory = {
  provide:'UserProvider', 
  useFactory:()=>(new UserProvider()),
  scope:Scope.REQUEST 
}


@Injectable({
  scope: Scope.REQUEST,
})
export class UserProvider {
  // @Inject(UserService)
  // private readonly usersvc:UserService;
  // private static instance: UserProvider;
  
  protected count:number = 0
  protected uid: string = '';
  protected _id: string = '';
  protected uname: string = '';
  protected email: string = '';
  protected fullname: string = '';
  protected xOrg: string = '';
  protected tenantId: number = 0;
  protected orgId: number = 0;
  protected branchId: number = 0;
  protected ssoACL: any = {};
  protected token: string = '';
  protected refreshtoken: string = '';
  protected group: string = '';
  protected roles: string[] = [Role.SuperAdmin,Role.SuperUser,Role.User];
  constructor() {
    
  }
  // public static getInstance(): UserProvider {
  //   if (!UserProvider.instance) {
  //     UserProvider.instance = new UserProvider();
  //   }
  //   return UserProvider.instance;
  // }
  getUid = () => this.uid;
  getUname = () => this.uname;
  getFullname = () => this.fullname;
  getTenantId = () => this.tenantId;
  getOrgId = () => this.orgId;
  getBranchId = () => this.branchId;
  getEmail = () => this.email;
  getGroup = () => this.group;
  getRoles = () => this.roles;

  setCurrentUserInfo = (tokenstr: string,xorg)=>{
    this.setUserToken(tokenstr)
    this.setXorg(xorg);      
  }
  setUserToken = async (tokenstr: string) => {
    this.count++
    const tokeninfo = jwt.decode(tokenstr);  
    
    this.token = tokenstr;
    this.uid = tokeninfo.sub;
    this.email = tokeninfo.email;
    this.uname = tokeninfo.preferred_username;
    this.fullname = tokeninfo.name;    
    this.ssoACL = tokeninfo.resource_access;
    
    try{
      
      await connect(process.env.MONGODB_URL);
      const usermodel = model<User>('user',UserMongoSchema,'user')
      const filter ={ssoId: this.uid,}
      const users = await usermodel.find(filter)
      
      if(!users || users.length ==0){
        //console.log("User not found")        
        this.group = 'Unknown'        
        this.roles = [Role.Everyone,Role.Unknown]
        this._id = '';
      }else{
        const userinfo = users[0]
        console.log("userinfo ",userinfo)
        const currentbranch=this.branchId
        const currentorg = this.orgId   
        this.group = 'manager'
        this._id = userinfo._id
        this.roles = rolegroups[this.group]   
        if(!this.roles.includes(Role.Everyone)){
          this.roles.push(Role.Everyone)        
        }
        
      }

      if(this.isRealmAdmin() && !this.roles.includes(Role.SuperAdmin)){
        this.roles.push(Role.SuperAdmin)
      }
      
      // const currentbranchinfo = _.filter(searchresult,(item)=>{
        // return item['isactive']== true
        // && item['branch']['branchId']==currentbranch && item['branch']['orgId']==currentorg
      // })
      
      //console.log("currentbranchinfo",currentbranchinfo)
      // if( currentbranchinfo.length>0){
      //   u.group = currentbranchinfo[0]['group'] ?? ''
      
      // }else{
        
      //   //u.roles = []
      // }
      
      
        
    }catch(err){
      console.log("-------------errors----s----s----s----s-----",err)
    }  
  };
  
  getInfo = () => {    
    return this;
  };
  getBranchFilter = () => {
    return {
      tenantId: this.tenantId,
      orgId: this.orgId,
      branchId: this.branchId,
    };
  };
  getTenantFilter = () => {
    return { tenantId: this.tenantId };
  };
  getOrgFilter = () => {
    return {
      tenantId: this.tenantId,
      orgId: this.orgId,
    };
  };
  getWorkflowTaskFilter() {
    return {
      'data.tenantId': this.tenantId,
      'assignments.assignee': this.getUid(),
      // 'assignments.assignee': User.getInstance().getUid(),
    };
  }
  getCreateFilter = () => {
    const u = this;
    return {
      tenantId: u.tenantId,
      orgId: u.orgId,
      branchId: u.branchId,
      createdby: u.uid,
      updatedby: u.uid,
      created: new Date().getTime().toString(),
      updated: new Date().getTime().toString(),
    };
  };
  getUpdateFilter = () => {
    const u = this;
    return {
      updatedby: u.uid,
      updated: new Date().getTime().toString(),
    };
  };
  setXorg = (xorg) => {
    try {
      const decodedText: string = Base64URL.decodeText(xorg);
      const arrXorg = decodedText.split('-');

      if (arrXorg.length == 3) {
        const u = this;
        u.tenantId = Number(arrXorg[0]);
        u.orgId = Number(arrXorg[1]);
        u.branchId = Number(arrXorg[2]);        
      } else {
        throw 'invalid x-org';
      }
    } catch (err) {
      throw err;
    }
  };


  async getUserInfo(){
    const userinfo = {
      _id: this._id ,
      count: this.count,
      tenantId: this.getTenantId(),
      orgId: this.getOrgId(),
      branchId: this.getBranchId(),
      email: this.getEmail(),
      ssoId: this.getUid(),
      fullName: this.getFullname(),
      group: this.group,
      roles: this.getRoles()
    }
    // console.log("this.usersvc",typeof this.usersvc)
    // @InjectModel('user')  
    // const usermodel = model<User>('user',userMongoSchema)
    
    // // const schema =  
    // const allorgs:any[] = await this.usersvc.getAllMyOrganization()
    // const allxorgs = []
    // // console.log('allorgs',allorgs)
    // for(let i=0; i<allorgs.length; i++){
    //   const o = allorgs[i]
    //   const tenantId = o.tenantId
    //   const orgId=o.orgId
      
    //   for(let j=0; j<o.branches.length;j++){
    //     const b = o.branches[j]
        
    //     if(b.isactive == true && b.group!='' ){
    //       const rawxorg = tenantId+'-'+b.branch.orgId+'-'+b.branch.branchId        
          
    //       const tmp = {
    //         "orgId":b.branch.orgId,
    //         "orgCode":b.branch.orgCode,
    //         "orgName":b.branch.orgName,
    //         "branchName":b.branch.branchName,
    //         "branchCode":b.branch.branchCode,
    //         "branchId":b.branch.branchId,
    //         "xorg":Base64URL.encodeText(rawxorg)
    //       }
    //       // console.log("RES",rawxorg,tmp)
    //       allxorgs.push(tmp)
          
    //     }
    //   }

    // }

    
    

    return userinfo
  }


  isRealmAdmin = ()=>{
    const o = this.ssoACL    
    const ssoclient = process.env.OAUTH2_CLIENTID
    const adminRole = process.env.OAUTH2_ADMINROLE    
    if( o[ssoclient] && o[ssoclient]['roles'] && o[ssoclient]['roles'] == adminRole ){
      //console.log("isadmin")
          return true
    }else{     
      //console.log("not admin")
      return false
    }
    
  }
}
