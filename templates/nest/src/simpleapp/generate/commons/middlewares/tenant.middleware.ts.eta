/**
 * This file was automatically generated by simpleapp generator. Every
 * MODIFICATION OVERRIDE BY GENERATEOR
 * last change 2025-08-27
 * Author: Ks Tan
 */

import Base64URL from '@darkwolf/base64url';
import { BadRequestException, Injectable, Logger, NestMiddleware, ServiceUnavailableException } from '@nestjs/common';
import { InjectModel } from '@nestjs/mongoose';
import { NextFunction, Request, Response } from 'express';
import { Model } from 'mongoose';
import { Permission } from '../../types/perm.type';
import { User } from '../../types/user.type';
import { Appintegration } from '../../types/appintegration.type';
import { Miniappinstallation, Webhook } from '../../types';
import { UserContext } from '../user.context';
import { ApiKeyService } from './api-key/api-key.service';
import { HEADER_X_API_KEY, HEADER_X_API_SECRET } from '../constants/header';
import {Environment} from '../../../maintenance/apischemas/environment'
@Injectable()
export class TenantMiddleware implements NestMiddleware {
  protected defaultXOrg = Base64URL.encodeText('0-0-0');

  protected excludeXOrgPaths = ['/profile', '/profile/tenant', '/profile/session'];

  private readonly logger = new Logger(this.constructor.name);

  constructor(
    @InjectModel('User') private readonly userModel: Model<User>,
    @InjectModel('Permission') private readonly permModel: Model<Permission>,
    @InjectModel('Appintegration') private readonly appModel: Model<Appintegration>,
    @InjectModel('Webhook') private readonly webhookModel: Model<Webhook>,
    @InjectModel('Miniappinstallation') private readonly miniAppInstallationModel: Model<Miniappinstallation>,
    @InjectModel('Environment') private envModel:Model<Environment>,
    private readonly apiKeyService: ApiKeyService,
  ) {}

  requireXOrg(baseurl: string): boolean {
    for (let i = 0; i < this.excludeXOrgPaths.length; i++) {
      if (baseurl.includes(this.excludeXOrgPaths[i])) {
        this.logger.verbose('requireXOrg = false');
        return false;
      }
    }
    return true;
  }

  async use(req: Request, res: Response, next: NextFunction) {
    if (req.baseUrl == '/oauth2-redirect.html') {
      next();
      return;
    }

    const envs = await this.envModel.find()
    let maintenanceMode = false
    if(envs){
      maintenanceMode = !envs[0].systemEnable  
    }
    

    let tokenStr: string = req.get('authorization') ?? '';
    tokenStr = tokenStr.replace('Bearer ', '');
    const xOrg = req.get('x-org') ?? this.defaultXOrg;

    const user = new UserContext(this.userModel, this.permModel, this.appModel, this.miniAppInstallationModel);

    if (req.baseUrl == '/graphql') {
      if (tokenStr) {
        await user.setCurrentUserInfo(tokenStr, xOrg, this.webhookModel);
      }

      if(maintenanceMode && !user.isRealmAdmin()){
        throw new ServiceUnavailableException("System in maintenance mode")
      }

      req['sessionuser'] = user;
      next();
      return;
    }
    this.logger.debug(`Running TenantMiddleware for ${req.baseUrl}`);

    // Request Using API Key & Secret
    const isApiKeyRequest = process.env.X_APIKEY && req.get(HEADER_X_API_KEY) && req.get(HEADER_X_API_SECRET);
    if (isApiKeyRequest) {
      try {
        await this.apiKeyService.validate(req, user);

        req['sessionuser'] = user;
        if(maintenanceMode){
          throw new ServiceUnavailableException("System in maintenance mode")
        }
        next();
        return;
      } catch (e) {
        throw e;
      }
    }

    // If X_APIKEY defined, and there is api key and secret supplied. use robot user
    // if (process.env.X_APIKEY && req.get('x-apikey') && req.get('x-apisecret')) {
    //   if (req.get('x-apikey') == process.env.X_APIKEY && req.get('x-apisecret') == process.env.X_APISECRET) {
    //     user.setAsStaticUser('00000000-0000-0000-0000-000000000000', 'robot', 'Robot', 'robot@a.org', req.get('x-org') ?? this.defaultXOrg);
    //     if (req.get('x-guest-accesstoken')) {
    //       user.setGuestToken(req.get('x-guest-accesstoken'));
    //     }

    //     req['sessionuser'] = user;
    //     next();
    //     return;
    //   } else {
    //     this.logger.log('Invalid API Key / Secret');
    //     throw new BadRequestException('Invalid API Key / Secret');
    //   }
    // }

    if (!req.get('authorization')) {
      this.logger.log('Undefine Bearer Token');
      return res.status(401).send('Undefine Bearer Token');
    }

    if (!req.get('x-org') && this.requireXOrg(req.baseUrl)) {
      this.logger.log('Undefine header X-Org and require that at ' + req.baseUrl, 'TenantMiddleware');
      throw new BadRequestException('Undefine header X-Org');
    }

    try {
      await user.setCurrentUserInfo(tokenStr, xOrg, this.webhookModel);

      if(maintenanceMode && !user.isRealmAdmin()){
        throw new ServiceUnavailableException("System in maintenance mode")
      }


      user.detectMiniAppSdkRequest(req);
      if (user.getId() == '' && this.requireXOrg(req.baseUrl)) {
        this.logger.log('Access deny for user:', req.baseUrl);
        return res.status(401).send('Access deny for user');
      } else {
        if (user.getId() == '') {
          this.logger.verbose(`Grant new user (${user.getUid()}) access ${req.baseUrl}`);
        } else {
          this.logger.verbose(`Grant user (${user.getId()}) access ${req.baseUrl}`);
        }
        req['sessionuser'] = user;
        this.logger.verbose('User roles: ' + user.getRoles().join(','));

        next();
        return;
      }
    } catch (err) {
      let errorMsg: string = <string>err;
      if (err instanceof Error) {
        errorMsg = 'Code: ' + err.name + ', Msg: ' + err.message;
      }
      this.logger.error('Error set user context: ' + errorMsg);
      throw new BadRequestException(err);
    }
  }
}
