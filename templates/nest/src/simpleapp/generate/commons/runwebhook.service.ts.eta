/**
 * This file was automatically generated by simpleapp generator. Every
 * MODIFICATION OVERRIDE BY GENERATEOR
 * last change 2024-03-17
 * Author: Ks Tan
 */
import { BadRequestException, Injectable,Inject, InternalServerErrorException, Logger, NotFoundException } from '@nestjs/common';
import { EventEmitter2, OnEvent } from '@nestjs/event-emitter';
import { UserContext } from './user.context';
import { Webhook,Webhooklog } from '../types';
import { alldocuments } from 'src/simpleapp/generate/commons/dicts/documents';

@Injectable()
export class RunWebhookService {
  @Inject(EventEmitter2)
  protected eventEmitter: EventEmitter2;

  protected logger = new Logger();
  protected maxRetries = 5
  public constructor() {}



  /**
   * trigger
   */
  async run(appuser: UserContext, documentName: string, actionName: string, data: any) {
    return await this.runRealtimeWebHook(appuser,documentName,actionName,data)
  }
  /**
   * get/delete
   * http://myendpoint.com/{orgid}/invoice/{documentid}/delete
   * http://myendpoint.com/{orgid}/invoice/{documentid}?action=delete
   * 
   * post/put/patch
   * http://myendpoint.com/{orgid}/invoice/{documentid}
   * {json body}
   */
  async runRealtimeWebHook(appuser: UserContext, documentName: string, actionName: string, data: any) {
    this.logger.debug(`Run webhook ${documentName}, ${actionName}`);
    // console.log(`Run webhook ${documentName}, ${actionName}`);


    const webhooks = appuser.getWebHooks().filter(wh=>
      wh.resourceName==documentName && wh.eventType==actionName 
      )
    // console.log(webhooks);
    
    //same resource,actionName may have multiple webhook, run 1 by 1
    for(let whNo=0;whNo<webhooks.length;whNo++){    

      const webhook = webhooks[whNo]
      const reqMethod = webhook.requestMethod
      this.logger.verbose(webhook)
      const headers = {};
      
      if (Array.isArray(webhook.headers)) {
        webhook.headers.forEach((h) => {
          h.value = h.value.replace('{{access_token}}',appuser.getUserToken())          
          headers[h.name] = h.value;
        });
      }
      headers['accept'] = 'application/json';
      headers['content-type'] = 'application/json';
      headers['x-org']=appuser.getXOrg()
      headers['x-resource-name']=documentName
      headers['x-action-name']=actionName

      if(webhook.authentication=='basic')
      headers['Authorization']= 'Basic ' + Buffer.from(webhook.basicAuth.user + ":" + webhook.basicAuth.password).toString('base64');

      let tries = webhook.retryAttemps ?? 0
      //first try need + 1
      tries = tries+1
      //hardcode max retries
      if(tries > this.maxRetries) tries = this.maxRetries
      const options:RequestInit = {
        method: reqMethod.toUpperCase(),
        headers: headers,

      };
      try {
        if(['POST','PUT','PATCH'].includes(options.method)){
          options.body= this.prepareBody(webhook,data)
        }



        
        while(tries>0){
          tries--
          console.log("Excute webhook id",webhook._id)
          const req = await fetch(webhook.url, options);
          const statusCode = req.status;        
           

          
          if (statusCode >= 200 && statusCode <= 300) {
            //success, continue next webhook
            const msg = `webhook triggered successfully for ${documentName}:${actionName}. ${reqMethod} ${webhook.url}, try:${tries}, ${statusCode},${req.statusText}`
            this.addLog(appuser,documentName,webhook,actionName,data,options,"success",statusCode,msg)          
            break;
          }else if(tries<=0 && webhook.jobType=='roll-back-when-failed'){          
            //failed, trigger server error for roll back
            const msg = `webhook faied, data roll back ${documentName}:${actionName}. ${reqMethod} ${webhook.url}, try:${tries}, ${statusCode},${req.statusText}`
            this.addLog(appuser,documentName,webhook,actionName,data,options,'failed',statusCode,msg)          
            throw new InternalServerErrorException(msg);
          }else if(tries<=0 && webhook.jobType=='realtime'){
            //failed, but no need to trigger server error/rollback
            const msg = `webhook failed, ${documentName}:${actionName}. ${reqMethod} ${webhook.url}, try:${tries},  ${statusCode},${req.statusText}`
            this.addLog(appuser,documentName,webhook,actionName,data,options,'failed',statusCode,msg)            
          }else{
            //failed, but still continue retry
            const msg = `webhook ${documentName}:${actionName}. ${reqMethod} ${webhook.url}, try:${tries},  ${statusCode},${req.statusText}`
            this.addLog(appuser,documentName,webhook,actionName,data,options,'warn',statusCode,msg)
          }
          
        }

        // const body = req.body;
      } catch (e) {
        throw new InternalServerErrorException(e);
      }

    }

    return true
  }


  addLog(appuser: UserContext, documentName: string, webhook:Webhook, actionName: string, data: any,options,status:string,statusCode:number,msg:string){


    if(status=='warn'){
      status="failed"
      this.logger.warn(msg)
    }
    else if(status=='success')
      this.logger.debug(msg)
    else 
      this.logger.error (msg)

    let body = JSON.stringify(options,null,4)
    
    const whlog: Webhooklog = {
      title: `${webhook.requestMethod} ${webhook.url}`,
      resource: documentName,
      actionName: actionName,
      status: status,
      statusCode: statusCode,
      body:  body,
      msg:msg
    }

    this.eventEmitter.emit('webhooklog.add', appuser,whlog);
  }
  prepareBody(webhook:Webhook,data:any){
    const cleandata = JSON.parse(JSON.stringify(data))

    if(webhook.body?.trim()=='*'){
      return JSON.stringify(cleandata)
    }
    const parse = require('json-templates');    
    const template = parse(webhook.body);    
    const x:BodyInit =template(cleandata)
    // this.logger.log(x)    
    return JSON.parse(JSON.stringify(x))
  }  
  
}
