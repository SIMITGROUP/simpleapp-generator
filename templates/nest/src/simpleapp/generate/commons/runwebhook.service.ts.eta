/**
 * This file was automatically generated by simpleapp generator. Every
 * MODIFICATION OVERRIDE BY GENERATEOR
 * last change 2024-03-17
 * Author: Ks Tan
 */
import { BadRequestException, Injectable, Inject, InternalServerErrorException, Logger, NotFoundException } from '@nestjs/common';
import { EventEmitter2, OnEvent } from '@nestjs/event-emitter';
import { UserContext } from './user.context';
import { Webhook, Webhooklog } from '../types';
import { alldocuments } from 'src/simpleapp/generate/commons/dicts/documents';

@Injectable()
export class RunWebhookService {
  @Inject(EventEmitter2)
  protected eventEmitter: EventEmitter2;

  protected logger = new Logger();
  protected maxRetries = 5;
  public constructor() {}

  /**
   * trigger
   */
  async run(appuser: UserContext, documentName: string, actionName: string, data: any) {
    if (process.env.WEBHOOK_ONOFF && process.env.WEBHOOK_ONOFF.toLowerCase() == 'on') return await this.runRealtimeWebHook(appuser, documentName, actionName, data);
    else this.logger.warn(`Webhook off, not run for ${documentName}:${actionName}`);
  }

  async runRealtimeWebHook(appuser: UserContext, documentName: string, actionName: string, data: any) {
    this.logger.debug(`Run webhook ${documentName}, ${actionName}`);

    const webhooks = appuser.getWebHooks().filter((wh) => wh.resourceName == documentName && wh.eventType == actionName);
    // console.log(webhooks);

    const systemVars = {
      $xOrg: appuser.getXOrg(),
      $accessToken: appuser.getUserToken(),
      $fullName: appuser.getFullname(),
      $email: appuser.getEmail(),
      $uid: appuser.getUid(),
      $resourceName: documentName,
      $actionName: actionName,
      $url: process.env.APP_URL ?? 'http://localhost:8080',
    };

    //same resource,actionName may have multiple webhook, run 1 by 1
    for (let whNo = 0; whNo < webhooks.length; whNo++) {
      const webhook = webhooks[whNo];
      //danger!! system webhook, only private webhook will allow access
      if (webhook._id.includes('private.')) systemVars['$automationApiKey'] = process.env.DEFAULT_AUTOMATION_API_KEY ?? '';

      const reqMethod = webhook.requestMethod;
      let webhookUrl = webhook.url;
      // this.logger.verbose(webhook);
      const headers = {};

      Object.keys(systemVars).forEach((k) => {
        webhookUrl = webhookUrl.replace('{{' + k + '}}', systemVars[k]);
      });

      if (Array.isArray(webhook.headers)) {
        webhook.headers.forEach((h) => {
          let headerValue = h.value ?? '';
          Object.keys(systemVars).forEach((k) => {
            headerValue = headerValue.replace('{{' + k + '}}', systemVars[k]);
          });

          headers[h.name] = headerValue;
        });
      }
      headers['accept'] = 'application/json';
      headers['content-type'] = 'application/json';

      if (webhook.authentication == 'basic') headers['Authorization'] = 'Basic ' + Buffer.from(webhook.basicAuth.user + ':' + webhook.basicAuth.password).toString('base64');

      let tries: number = webhook.retryAttemps ?? 0;

      tries = tries + 1;

      if (tries > this.maxRetries) tries = this.maxRetries;
      const maxtries = tries;
      const options: RequestInit = {
        method: reqMethod.toUpperCase(),
        headers: headers,
      };

      // console.log("options",options)

      if (['POST', 'PUT', 'PATCH'].includes(options.method)) {
        options.body = this.prepareBody(appuser, webhook, data, systemVars);
      }

      while (tries > 0) {
        // console.log(`Excute webhook id ${webhook._id} max ${tries}`);
        tries--;
        let req: Response;
        let msg = '';
        let statusCode = 0;
        const tryno = maxtries - tries;
        try {
          req = await fetch(webhookUrl, options);
          statusCode = req.status;
          //sucess, break and no more retry
          msg = `Try: ${tryno}/${maxtries} ${documentName}:${actionName}, ${reqMethod} ${webhookUrl}, ${statusCode},${req.statusText}`;
          if (statusCode >= 200 && statusCode <= 300) {
            //success, continue next webhook
            this.addLog(appuser, documentName, webhook, actionName, data, options, 'success', statusCode, msg);
            break;
          } else {
            //common error like 404
            this.addLog(appuser, documentName, webhook, actionName, data, options, 'failed', statusCode, msg);
          }
        } catch (e) {
          // exception, usually server not accessible. use error 500
          msg = `Try: ${tryno}/${maxtries}, error ${documentName}:${actionName}  (${webhook._id}) ${e} at ${webhookUrl}`;
          this.addLog(appuser, documentName, webhook, actionName, data, options, 'failed', 500, msg);
        }

        //finish tries, throw error
        if (tries == 0 && webhook.jobType == 'roll-back-when-failed') {
          throw new InternalServerErrorException(msg);
        }
      } //end retries
    } //next webhook

    return true;
  }

  addLog(appuser: UserContext, documentName: string, webhook: Webhook, actionName: string, data: any, options, status: string, statusCode: number, msg: string) {
    if (status == 'success') {
      this.logger.debug(msg);
    } else {
      this.logger.warn(msg);
    }
    const logbody = options.body;
    let body = JSON.stringify(logbody, );

    const whlog: Webhooklog = {
      _id: crypto.randomUUID(),
      tenantId: appuser.getTenantId(),
      orgId: appuser.getOrgId(),
      branchId: appuser.getBranchId(),
      webHookId: webhook._id,
      created: new Date().toISOString(),
      createdBy: appuser.getUid(),
      title: `${webhook.requestMethod} ${webhook.url}`,
      resource: documentName,
      actionName: actionName,
      status: status,
      statusCode: statusCode,
      body: logbody,
      msg: msg,
    };

    this.eventEmitter.emit('webhooklog.add', appuser, whlog);
  }
  prepareBody(appuser: UserContext, webhook: Webhook, data: any, systemVars: any) {
    const cleandata = JSON.parse(JSON.stringify(data));

    if (webhook.body?.trim() == '*') {
      return JSON.stringify(cleandata);
    }
    const finaldata = { ...cleandata, ...systemVars };

    const parse = require('json-templates');
    const template = parse(webhook.body);
    const x: BodyInit = template(finaldata);
    // this.logger.log(x)
    return JSON.parse(JSON.stringify(x));
  }
}
