/**
 * This file was automatically generated by simpleapp generator. Every
 * MODIFICATION OVERRIDE BY GENERATEOR
 * last change 2023-10-28
 * Author: Ks Tan
 */
import { Injectable, Scope,Inject,Logger, BadRequestException } from '@nestjs/common';
import { Model, model, connect, PipelineStage } from 'mongoose';
import _ from 'lodash'
import { Module } from '@nestjs/common';
import * as jwt from 'jsonwebtoken';
import { Role } from './roles/roles.enum';
import * as rolegroups from './roles/roles.group'
import { UserService } from './../../services/user.service';
import { InjectModel } from '@nestjs/mongoose';
const Base64URL = require('@darkwolf/base64url');
import { UserMongoSchema } from './../models/user.model';
import {   User,  }  from './../types/user.type';
import {   Permission,  }  from './../types/perm.type';
import {ProfileUserBranch , ProfileUserInvites} from '../../profile/profile.types'

import {ClientSession}  from 'mongoose'
@Injectable()
export class UserContext {
  protected logger = new Logger()
  protected uid: string = '';
  protected _id: string = '';
  protected uname: string = '';
  protected email: string = '';
  protected fullname: string = '';
  protected xOrg: string = '';
  protected tenantId: number = 0;
  protected orgId: number = 0;
  protected branchId: number = 0;
  protected ssoACL: any = {};
  protected token: string = '';
  protected refreshtoken: string = '';
  protected group: string = '';
  protected branchCode: string = '';
  protected branchName: string = '';  
  protected orgCode: string = '';
  protected orgName: string = '';  
  protected branches: any[] = []
  protected invites: any[] = []  //User + field tenant:Tenant[]
  protected roles: string[] = [];
  

  constructor(
    private readonly usermodel:Model<User>,
    private readonly permmodel:Model<Permission>,
    private dbsession:ClientSession
    ) {
    
  }
  getDBSession = ():ClientSession => this.dbsession

  getId = () => this._id;
  getUid = () => this.uid;
  getUname = () => this.uname;
  getFullname = () => this.fullname;
  getTenantId = () => this.tenantId;
  getOrgId = () => this.orgId;
  getBranchId = () => this.branchId;
  getEmail = () => this.email;
  getGroup = () => this.group;
  getRoles = () => this.roles;
  getBranches = ():ProfileUserBranch[] => {
    this.branches;
    const data:ProfileUserBranch[] = []

    if(this.branches){
      for(let i=0;i<this.branches.length; i++){
        const b= this.branches[i]
        data.push({
          _id: b._id,          
          branch: b.branch[0],
          group: b.group,
          xOrg: this.generateXorg(b.tenantId,b.orgId,b.branchId)

        })
      }
    }
    return data
    
  }
  getInvites = ():ProfileUserInvites[] =>{
    
    // const usermodel = model<User>('user',UserMongoSchema,'user')    
    
    const data:ProfileUserInvites[] = []
    if( this.invites){
      // console.log("getInvites",res)
      for(let i=0;i< this.invites.length; i++){
        const r =  this.invites[0]
        
        data.push({
          _id: r._id,
          email: r.email,
          tenantId: r.tenantId,
          fullName: '',
          tenantName: r.tenant[0].tenantName,
          created: r.created,
        })
      }
    }
    return data    
    
    };
  setCurrentUserInfo = async (tokenstr: string,xorg)=>{
    this.setXorg(xorg);      
    await this.setUserToken(tokenstr)
    
  }

  /**
   * obtain user profile filter by uid,tenantId,orgId,branchId
   * @returns Promise<User|undefined>
   */
  obtainProfileFromDb = async () : Promise<User|undefined>=>{
    const filter = { $match:{uid:this.uid,tenantId:this.tenantId} }
    
    


    const joinpermission:PipelineStage = {$lookup: {
      from : 'permission',
      localField : 'uid',
      foreignField : 'uid',
      as : 'permissions',
      pipeline:[
          { $match:{
            uid:this.uid,
            tenantId:this.tenantId,
            orgId:this.orgId,
            branchId:this.branchId,            
          }},
          {$lookup:{from: 'branch',localField: 'branchId',foreignField:'branchId',as: 'currentbranch'}},
          {$lookup:{from: 'organization',localField: 'orgId',foreignField:'orgId',as: 'currentorg'}}
        ]
    }}

    const pipeline:PipelineStage[]=[filter,]

    if(this.tenantId>0){
      pipeline.push(joinpermission)
    }
    // console.log("obtainProfileFromDbobtainProfileFromDb ",pipeline)
    // const users = await usermodel.find(filter)
    const users = await this.usermodel.aggregate(pipeline)
    this.logger.verbose(`aggregate user profile from database`,'obtainProfileFromDb' )   
    this.logger.verbose(pipeline,'obtainProfileFromDb x' )   
    this.logger.verbose(users,'obtainProfileFromDb' )   
    // console.log("obtainProfileFromDbobtainProfileFromDb ",users)
    if(users && users.length>0){
      const userinfo = users[0]
      // console.log("userinfouserinfouserinfouserinfouserinfouserinfo ",userinfo)

      if(this.tenantId>0){
        const myperm=userinfo.permissions[0]
        if(myperm && myperm.group){
          userinfo.group = myperm.group                    
          userinfo.roles = rolegroups[userinfo.group]   
          userinfo.branchCode = myperm.currentbranch[0].branchCode
          userinfo.branchName = myperm.currentbranch[0].branchName          
          userinfo.orgCode = myperm.currentorg[0].orgCode
          userinfo.orgName = myperm.currentorg[0].orgName
        }    
      }else{        
        userinfo.group = '' 
      }
      
      return userinfo  
    }else{
      return undefined
    }
    
  }
  setUserToken = async (tokenstr: string) => {    

    //define token info
    const tokeninfo = jwt.decode(tokenstr);      
    this.token = tokenstr;
    this.uid = tokeninfo.sub;
    this.email = tokeninfo.email;
    this.uname = tokeninfo.preferred_username;
    this.fullname = tokeninfo.name;    
    this.ssoACL = tokeninfo.resource_access;    
    this.logger.verbose(`set token ${this.uid}`)   
    //read current user from db
    // console.log("await this.obtainProfileFromDb()")
    const userinfo = await this.obtainProfileFromDb()      
    this.logger.verbose(userinfo,'obtainProfileFromDb result')    
    if(userinfo){
      this.logger.debug(`${this.uid} user exists in tenant (${this.tenantId})`,'setUserToken' )   

      this._id = userinfo._id.toString()
      this.branchCode = userinfo['branchCode'] ?? ''
      this.branchName = userinfo['branchName'] ?? ''
      this.orgCode = userinfo['orgCode'] ?? ''
      this.orgName = userinfo['orgName'] ?? ''
      this.group = userinfo['group'] ?? ''
      this.roles = userinfo['roles'] ?? [Role.Everyone,Role.User]
    }else{
      this.logger.debug(`Set unknown id of current user`,'setUserToken' )   
      // this.group = ''
      // this.tenantId=0
      // this.orgId=0
      // this.orgCode=0
      this.roles = [Role.Everyone,Role.Unknown]
    }
    this.logger.debug(`${this.uid} have _id (${this.getId()}), group (${this.group}) and role (${this.getRoles()})` )   

    if(this.isRealmAdmin() && !this.roles.includes(Role.SuperAdmin)){
      this.roles.push(Role.SuperAdmin)
    }
    this.logger.verbose(this)   
  };


  generateXorg = (tenantId:number,orgId:number,branchId:number):string=>{
    return Base64URL.encodeText(`${tenantId}-${orgId}-${branchId}`)
  }
  getInfo = () => {    
    return this;
  };
  getBranchFilter = () => {
    return {
      tenantId: this.tenantId,
      orgId: this.orgId,
      branchId: this.branchId,
    };
  };
  getTenantFilter = () => {
    return { tenantId: this.tenantId };
  };
  getOrgFilter = () => {
    return {
      tenantId: this.tenantId,
      orgId: this.orgId,
    };
  };
  getWorkflowTaskFilter() {
    return {
      'data.tenantId': this.tenantId,
      'assignments.assignee': this.getUid(),
      // 'assignments.assignee': User.getInstance().getUid(),
    };
  }
  getCreateFilter = () => {
    const u = this;
    return {
      tenantId: u.tenantId,
      orgId: u.orgId,
      branchId: u.branchId,
      createdby: u.uid,
      updatedby: u.uid,
      created: new Date().toISOString(),
      updated: new Date().toISOString()
    };
  };
  getUpdateFilter = () => {
    const u = this;
    return {
      updatedby: u.uid,
      updated: new Date().toISOString()
    };
  };  
  setXorg = (xorg) => {
    try {
      const decodedText: string = Base64URL.decodeText(xorg);
      const arrXorg = decodedText.split('-');

      if (arrXorg.length == 3) {
        const u = this;
        u.tenantId = Number(arrXorg[0]);
        u.orgId = Number(arrXorg[1]);
        u.branchId = Number(arrXorg[2]);     
        
      } else {
        throw 'invalid x-org';
      }
    } catch (err) {
      throw err;
    }
  };


  async getUserInfo(){
     
    // obtain basic user info
    const userinfo = {
      _id: this.getId() ,
      tenantId: this.getTenantId(),
      orgId: this.getOrgId(),
      branchId: this.getBranchId(),
      branchCode: this.branchCode,
      branchName: this.branchName,
      orgCode:this.orgCode,
      orgName:this.orgName,
      email: this.getEmail(),
      uid: this.getUid(),
      fullName: this.getFullname(),
      group: this.group,
      roles: this.getRoles(),
      branches: this.getBranches(),
      invites: await this.getInvites()
    }
    this.logger.debug(userinfo,"init getUserInfo()")

    if(this.getId()!=''){
      this.logger.debug(userinfo,"obtain permissions and invitations")
      const filter:PipelineStage ={ $match:{uid:this.uid }} as PipelineStage
      const permission:PipelineStage = {$lookup: {
      from : 'permission',
      localField : 'uid',
      foreignField : 'uid',
      as : 'permissions',
      pipeline:[
        {$match:{uid: this.uid,},},
        {$lookup:{from : 'branch',localField : 'branchId',foreignField : 'branchId',as : 'branch',}},
      ]
    }}
    const lookupinvitation:PipelineStage = {$lookup: {
      from : 'user',
      localField : 'email',
      foreignField : 'email',
      as : 'invites',
      pipeline:[
        {$match:{uid: ''}},
        {$lookup:{from : 'tenant',localField : 'tenantId',foreignField : 'tenantId',as : 'tenant',}},
      ]
    }}

    const pipeline:PipelineStage[]=[
      filter,
      permission,
      lookupinvitation
    ]
    this.logger.debug(pipeline,"getUserInfo")
    // // // const users = await usermodel.find(filter)
    const users = await this.usermodel.aggregate(pipeline)

    
    this.invites = users[0].invites
    this.branches = users[0].permissions
    this.logger.verbose(users,"getUserInfo")
    userinfo.branches=this.getBranches()
    userinfo.invites=this.getInvites()
    // this.logger.debug(`getUserInfo result ${userinfo}`)
    
    }else{
      this.logger.log(`${this.getUid()} does not exists in current tenant (${this.tenantId})`)
    }
    

    return userinfo
  }
  async decideInvitation (id:string, decision:string):Promise<boolean> {
    
    // const usermodel = model<User>('user',UserMongoSchema,'user')
    const res = await this.usermodel.findById(id)
    // console.log("find invitation:",res)
    if(!res.uid){
      res.uid = this.getUid()
      res.fullname = this.fullname
      res.active = true
      
      if(decision=='accept'){
        const result = await res.save({session:this.dbsession})
        this.logger.log(result,"accept invitation 1")
        //set permission of all user under this.user_id
        const updateresult = await this.permmodel.updateMany({ uid:'',user_id:res._id},{uid:this.getUid()}).session(this.dbsession)
        this.logger.log(updateresult,"update all permission")
        return true
      }else{
        const deleteresult = await this.usermodel.deleteOne({_id: id}).session(this.dbsession)         
        await this.permmodel.deleteMany({ uid:'',user_id:res._id}).session(this.dbsession)
        return true
      }          
    }else{
      throw new BadRequestException(`${id} not found.`)
    }    

  }

  isRealmAdmin = ()=>{
    const o = this.ssoACL    
    const ssoclient = process.env.OAUTH2_CLIENTID
    const adminRole = process.env.OAUTH2_ADMINROLE    
    if( o[ssoclient] && o[ssoclient]['roles'] && o[ssoclient]['roles'] == adminRole ){
      //console.log("isadmin")
          return true
    }else{     
      //console.log("not admin")
      return false
    }
    
  }
}
