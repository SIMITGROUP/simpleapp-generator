/**
 * This file was automatically generated by simpleapp generator. Every
 * MODIFICATION OVERRIDE BY GENERATEOR
 * Permission design
 * 1. During sign in, user can pick run as what group user
 * 2.
 */
import Base64URL from '@darkwolf/base64url';
import { InjectModel } from '@nestjs/mongoose';
import { BadRequestException, ForbiddenException, Injectable, Logger, Scope } from '@nestjs/common';
import * as jwt from 'jsonwebtoken';
import { ClientSession, Model, PipelineStage } from 'mongoose';
import { Branch, Organization, Permission, Tenant, TenantClientSetting, User, Appintegration, Webhook } from 'src/simpleapp/generate/types';
import { ProfileUserBranch, ProfileUserInvites } from '../../profile/profile.types';
import { ModifiedRecords } from '../types';
import { Role } from './roles/roles.enum';
import systemWebHooks from '../../webhooks';
import * as rolegroups from './roles/roles.group';


@Injectable({ scope: Scope.REQUEST })
export class UserContext {
  protected sessionId: string = crypto.randomUUID();

  protected logger = new Logger(this.constructor.name);

  protected uid: string = '';

  protected _id: string = '';

  protected uname: string = '';

  protected email: string = '';

  protected fullname: string = '';

  protected xOrg: string = '';

  protected tenantId: number = 0;

  protected orgId: number = 0;

  protected orgRecordId: string = '';

  protected branchRecordId: string = '';

  protected branchId: number = 0;

  protected ssoACL: Record<string, { roles: string[] }> = {};

  protected token: string = '';

  protected refreshtoken: string = '';

  // Guest access token obtain from header 'x-guest-accesstoken', during use x-apikey / x-apisecret
  protected guestToken?: string = '';

  protected guestInfo: {
    uid: string;
    uname: string;
    fullname: string;
    email: string;
  } = { uid: '', uname: '', fullname: '', email: '' };

  protected groups: string[] = [];

  protected branchCode: string = '';

  protected branchName: string = '';

  protected orgCode: string = '';

  protected orgName: string = '';

  protected timeZone: string = '';

  protected country: string = '';

  protected offsetMinute: number = 0;

  protected currency: string = '';

  protected branches: (Permission & { branch: Branch[] })[] = [];

  protected lastActivity: string = new Date().toISOString();

  protected invites: (ProfileUserInvites & { tenant: Tenant[] })[] = [];

  protected roles: Role[] = [];

  protected moreProps: Record<string, any> = {};

  protected package: string = '';

  protected webhooks: Webhook[] = systemWebHooks
  protected clientSetting: TenantClientSetting = {
    auditTrail: false,
    support: false,
    webhook: false,
    disableClassReminder: false,
  };

  private dbsession: ClientSession;
  
  protected modifiedRecords: ModifiedRecords = {
    createds: {},
    updateds: {},
    deleteds: {},
  };

  protected appintegration: {
    simbiz6: boolean;
    einvoice: boolean;
  } = { simbiz6: false, einvoice: false };

  constructor(
    private readonly userModel: Model<User>,    
    private readonly permModel: Model<Permission>,
    private readonly appModel: Model<Appintegration>,
  ) {}

  setDBSession = (dbsession: ClientSession) => {
    this.dbsession = dbsession;
  };

  getDBSession = (): ClientSession => this.dbsession;

  getId = () => this._id;

  getUid = () => this.uid;

  getUname = () => this.uname;

  getFullname = () => this.fullname;

  getTenantId = () => this.tenantId;

  getOrgId = () => this.orgId;

  getOrgRecordId = () => this.orgRecordId;

  getBranchRecordId = () => this.branchRecordId;

  getBranchId = () => this.branchId;

  getBranchName = () => this.branchName;

  getClientSetting = () => this.clientSetting;

  getBranchCode = () => this.branchCode;

  getEmail = () => this.email;

  getTimeZone = () => this.timeZone;

  getCountry = () => this.country;

  getOffsetMinute = () => this.offsetMinute;

  getGroups = () => this.groups;

  getCurrency = () => this.currency;

  getGuestInfo = () => this.guestInfo;

  getMoreProps = () => this.moreProps;

  getPackage = () => this.package;

  getRoles = () => this.roles;

  getModifieds = () => this.modifiedRecords;

  getBranches = (): ProfileUserBranch[] => {
    const data: ProfileUserBranch[] = [];

    if (Array.isArray(this.branches)) {
      for (let i = 0; i < this.branches.length; i++) {
        const branches = this.branches[i];
        data.push({
          _id: branches._id,
          branch: branches.branch[0],
          groups: branches.groups,
          xOrg: this.generateXOrg(branches.tenantId, branches.orgId, branches.branchId),
        });
      }
    }
    return data;
  };

  getInvites = (): ProfileUserInvites[] => {
    const data: ProfileUserInvites[] = [];
    if (this.invites) {
      for (let i = 0; i < this.invites.length; i++) {
        const invite = this.invites[i];
        data.push({
          _id: invite._id,
          email: invite.email,
          tenantId: invite.tenantId,
          fullName: '',
          tenantName: invite.tenant[0].tenantName,
          created: invite.created,
        });
      }
    }
    return data;
  };

  
  setCurrentUserInfo = async (tokenstr: string, xOrg: string,webhookModel:Model<Webhook>) => {
    this.setXOrg(xOrg);
    await this.setUserToken(tokenstr);   
    const wh = await webhookModel.find({branchId:this.getBranchId(),active:true})

    if(Array.isArray(wh) && wh.length>0)
      this.webhooks = this.webhooks.concat(wh)
  };

  /**
   * Obtain user profile filter by uid, tenantId, orgId, branchId
   * @returns Promise<User|undefined>
   */
  obtainProfileFromDB = async (): Promise<UserProfile | undefined> => {
    const filter = { $match: { uid: this.uid, tenantId: this.tenantId } };

    const joinPermission: PipelineStage = {
      $lookup: {
        from: 'permission',
        localField: '_id',
        foreignField: 'userId',
        as: 'permissions',
        pipeline: [
          {
            $match: {
              tenantId: this.tenantId,
              orgId: this.orgId,
              branchId: this.branchId,
            },
          },
          {
            $lookup: {
              from: 'branch',
              localField: 'branchId',
              foreignField: 'branchId',
              as: 'currentbranch',
            },
          },
          {
            $unwind: '$currentbranch',
          },
          {
            $lookup: {
              from: 'organization',
              localField: 'orgId',
              foreignField: 'orgId',
              as: 'currentorg',
            },
          },
          {
            $unwind: '$currentorg',
          },
          {
            $lookup: {
              from: 'tenant',
              localField: 'tenantId',
              foreignField: 'tenantId',
              as: 'currentTenant',
            },
          },
          
          {
            $unwind: '$currentTenant',
          },
        ],
      },
    };

    const pipeline: PipelineStage[] = [filter];

    if (this.tenantId > 0) {
      pipeline.push(joinPermission);
      pipeline.push({ $unwind: '$permissions' });
    }

    const userProfiles: UserProfile[] = await this.userModel.aggregate(pipeline);
    if (!userProfiles || userProfiles.length === 0) {
      return undefined;
    }

    const userProfile = userProfiles[0];

    if (this.tenantId > 0) {
      const userPermissions = userProfile.permissions;

      if (userPermissions && userPermissions.groups) {
        userProfile.groups = userPermissions.groups;
        userProfile.roles = [Role.Everyone, Role.User] as Role[];
        for (let g = 0; g < userProfile.groups.length; g++) {
          const roles: Role[] = (<() => Role[]>rolegroups[userProfile.groups[g]])();
          for (let r = 0; r < roles.length; r++) {
            if (!userProfile.roles.includes(roles[r])) {
              userProfile.roles.push(roles[r]);
            }
          }
        }
        if (userPermissions.currentTenant.owner.uid == userProfile.uid) {
          userProfile.roles.push(Role.TenantOwner);
        }
        userProfile.tenantRecordId = userPermissions.currentTenant._id;
        userProfile.package = userPermissions.currentTenant.package;
        userProfile.branchRecordId = userPermissions.currentbranch._id;
        userProfile.branchCode = userPermissions.currentbranch.branchCode;
        userProfile.branchName = userPermissions.currentbranch.branchName;
        userProfile.orgRecordId = userPermissions.currentorg._id;
        userProfile.orgCode = userPermissions.currentorg.orgCode;
        userProfile.orgName = userPermissions.currentorg.orgName;
        userProfile.timeZone = userPermissions.currentorg.timeZone;
        userProfile.currency = userPermissions.currentorg.currency;
        userProfile.country = userPermissions.currentorg.country;
        userProfile.offsetMinute = userPermissions.currentorg.offsetMinute;
        userProfile.clientSetting = userPermissions.currentTenant.clientSetting;
      }
    } else {
      userProfile.groups = [];
    }

    return userProfile;
  };

  getUserToken = () => this.token;

  setUserToken = async (tokenStr: string) => {
    this.logger.debug(`===setUserToken===`);
    // Define token info
    const tokeninfo: jwt.JwtPayload = jwt.decode(tokenStr) as jwt.JwtPayload;
    this.token = tokenStr;
    this.uid = tokeninfo?.sub ?? '';
    this.email = <string>tokeninfo?.email ?? '';
    this.uname = <string>tokeninfo?.preferred_username ?? '';
    this.fullname = <string>tokeninfo?.name ?? '';
    this.ssoACL = <Record<string, { roles: string[] }>>tokeninfo?.resource_access ?? {};
    this.logger.debug(`User found ${this.uid}`);

    const userProfile = await this.obtainProfileFromDB();
    if (userProfile) {
      this.logger.debug(`User ${this.uid} exists in tenant (${this.tenantId})`);

      this._id = userProfile._id.toString();
      this.branchCode = userProfile['branchCode'] ?? '';
      this.branchName = userProfile['branchName'] ?? '';
      this.orgCode = userProfile['orgCode'] ?? '';
      this.orgName = userProfile['orgName'] ?? '';
      this.timeZone = userProfile['timeZone'] ?? '';
      this.currency = userProfile['currency'] ?? '';
      this.country = userProfile['country'] ?? '';
      this.offsetMinute = userProfile['offsetMinute'] ?? 0;
      this.orgRecordId = userProfile['orgRecordId'] ?? '';
      this.branchRecordId = userProfile['branchRecordId'] ?? '';
      this.groups = userProfile['groups'] ?? [];
      this.clientSetting = userProfile['clientSetting'] ?? {};
      this.roles = userProfile['roles'] ?? [Role.Everyone, Role.User];
      this.moreProps = this.setMoreProps(userProfile);
      this.package = userProfile['package'];
      this.appintegration = await this.setAppIntegration();
    } else {
      this.logger.debug(`User ${this.uid} not exists in tenant (${this.tenantId})`);
      this.logger.debug(`Set unknown id of current user`);
      this.roles = [Role.Everyone, Role.Unknown];
    }

    if (this.isRealmAdmin() && !this.roles.includes(Role.SuperAdmin)) {
      this.roles.push(Role.SuperAdmin);
    }

    this.logger.verbose(`User ${this.uid} have _id (${this.getId()}), groups (${this.groups.join(',')}) and roles (${this.getRoles().join(',')}).`);
  };

  generateXOrg = (tenantId: number, orgId: number, branchId: number): string => {
    return Base64URL.encodeText(`${tenantId}-${orgId}-${branchId}`);
  };

  getInfo = () => {
    return this;
  };

  getBranchFilter = () => {
    return {
      tenantId: this.tenantId,
      orgId: this.orgId,
      branchId: this.branchId,
    };
  };

  getTenantFilter = () => {
    return { tenantId: this.tenantId };
  };

  getOrgFilter = () => {
    return {
      tenantId: this.tenantId,
      orgId: this.orgId,
    };
  };
  getWebHooks = ()=> this.webhooks
  
  getWorkflowTaskFilter() {
    return {
      'data.tenantId': this.tenantId,
      'assignments.assignee': this.getUid(),
    };
  }

  getCreateFilterWithId = () => {
    return {
      createdBy: this.uid,
      updatedBy: this.uid,
      created: new Date().toISOString(),
      updated: new Date().toISOString(),
    };
  };

  getCreateFilter = () => {
    return {
      tenantId: this.tenantId,
      orgId: this.orgId,
      branchId: this.branchId,
      createdBy: this.uid,
      updatedBy: this.uid,
      created: new Date().toISOString(),
      updated: new Date().toISOString(),
    };
  };

  getUpdateFilter = () => {
    return {
      updatedBy: this.uid,
      updated: new Date().toISOString(),
    };
  };

  setCurrentTenant(tenantId: number, orgId: number, branchId: number) {
    this.tenantId = tenantId;
    this.orgId = orgId;
    this.branchId = branchId;
  }

  getXOrg = () => this.xOrg;

  setXOrg = (xOrg: string) => {
    this.xOrg = xOrg;
    try {
      const decodedText: string = Base64URL.decodeText(xOrg);
      const xOrgRealm = decodedText.includes('/') ? decodedText.split('/') : decodedText.split('-');

      const value1 = Number(xOrgRealm[0]);
      const value2 = Number(xOrgRealm[1]);
      const value3 = Number(xOrgRealm[2]);
      if (xOrgRealm.length == 3 && !isNaN(value1) && !isNaN(value2) && !isNaN(value3)) {
        this.tenantId = value1;
        this.orgId = value2;
        this.branchId = value3;
      } else {
        throw new BadRequestException('invalidXorg');
      }
    } catch (err) {
      throw new BadRequestException(err);
    }
  };

  async getUserInfo(): Promise<UserInfo> {
    this.logger.debug('===getUserInfo===');

    const userinfo = {
      _id: this.getId(),
      sessionId: this.sessionId,
      tenantId: this.getTenantId(),
      orgId: this.getOrgId(),
      orgRecordId: this.orgRecordId,
      branchRecordId: this.branchRecordId,
      branchId: this.getBranchId(),
      branchCode: this.branchCode,
      branchName: this.branchName,
      orgCode: this.orgCode,
      orgName: this.orgName,
      timeZone: this.getTimeZone(),
      currency: this.getCurrency(),
      country: this.getCountry(),
      offsetMinute: this.getOffsetMinute(),
      email: this.getEmail(),
      uid: this.getUid(),
      fullName: this.getFullname(),
      groups: this.groups,
      roles: this.getRoles(),
      branches: this.getBranches(),
      invites: this.getInvites(),
      moreProps: this.getMoreProps(),
      appintegration: this.getAppIntegration(),
    };

    if (this.getId() != '') {
      this.logger.verbose('User Info: ' + JSON.stringify(userinfo));
      const filter: PipelineStage = {
        $match: {
          uid: this.uid,
          tenantId: this.tenantId,
        },
      };
      const permission: PipelineStage = {
        $lookup: {
          from: 'permission',
          localField: '_id',
          foreignField: 'userId',
          as: 'permissions',
          pipeline: [
            {
              $lookup: {
                from: 'branch',
                localField: 'branchId',
                foreignField: 'branchId',
                as: 'branch',
              },
            },
          ],
        },
      };
      const lookupInvitation: PipelineStage = {
        $lookup: {
          from: 'user',
          localField: 'email',
          foreignField: 'email',
          as: 'invites',
          pipeline: [
            { $match: { uid: '' } },
            {
              $lookup: {
                from: 'tenant',
                localField: 'tenantId',
                foreignField: 'tenantId',
                as: 'tenant',
              },
            },
          ],
        },
      };

      const pipeline: PipelineStage[] = [filter, permission, lookupInvitation];
      this.logger.verbose('User Info Pipeline: ' + JSON.stringify(pipeline));

      const userInvitationsAndPermissions: Array<{
        invites?: (ProfileUserInvites & { tenant: Tenant[] })[];
        permissions?: (Permission & { branch: Branch[] })[];
      }> = await this.userModel.aggregate(pipeline);

      this.logger.verbose('User invitations & permissions data: ' + JSON.stringify(userInvitationsAndPermissions));

      this.invites = userInvitationsAndPermissions[0].invites;
      this.branches = userInvitationsAndPermissions[0].permissions;

      userinfo.branches = this.getBranches();
      userinfo.invites = this.getInvites();
    } else if (this.getTenantId() > 0) {
      throw new ForbiddenException(`userNotExistInTenant`, 'Access Deny');
    }

    return userinfo;
  }

  async decideInvitation(id: string, decision: string): Promise<boolean> {
    const res = await this.userModel.findById(id);
    if (!res.uid) {
      res.uid = this.getUid();
      res.fullName = this.fullname;
      res.active = true;

      if (decision == 'accept') {
        const result = await res.save({ session: this.dbsession });
        this.logger.log(result, 'accept invitation 1');
        // Set permission of all user under this.user_id
        const updateresult = await this.permModel.updateMany({ uid: '', user_id: res._id }, { uid: this.getUid() }).session(this.dbsession);
        this.logger.log(updateresult, 'update all permission');
        return true;
      } else {
        await this.userModel.deleteOne({ _id: id }).session(this.dbsession);
        await this.permModel.deleteMany({ uid: '', user_id: res._id }).session(this.dbsession);
        return true;
      }
    } else {
      throw new BadRequestException(`${id} not found.`);
    }
  }

  isRealmAdmin = () => {
    const ssoACL = this.ssoACL;
    const ssoclient = process.env.OAUTH2_CLIENTID;
    const adminRole = process.env.OAUTH2_ADMINROLE;
    const adminemails = process.env.ADMIN_EMAIL.split(',');

    if (adminemails.includes(this.getEmail())) {
      return true;
    } else if (ssoACL[ssoclient] && ssoACL[ssoclient]['roles'] && ssoACL[ssoclient]['roles'].includes(adminRole)) {
      return true;
    } else {
      return false;
    }
  };

  searchInsertedRecordId(collection: string, _id: string) {
    if (!this.modifiedRecords.createds[collection]) {
      return undefined;
    }
    return this.modifiedRecords.createds[collection].find((item) => item === _id);
  }

  searchDeletedRecordId(collection: string, _id: string) {
    if (!this.modifiedRecords.deleteds[collection]) {
      return undefined;
    }
    return this.modifiedRecords.deleteds[collection].find((item) => item === _id);
  }

  addInsertedRecordId(collection: string, _id: string) {
    if (this.modifiedRecords.createds[collection]) {
      this.modifiedRecords.createds[collection].push(_id);
    } else {
      this.modifiedRecords.createds[collection] = [_id];
    }
  }

  addUpdatedRecordId(collection: string, _id: string) {
    if (this.modifiedRecords.updateds[collection]) {
      this.modifiedRecords.updateds[collection].push(_id);
    } else {
      this.modifiedRecords.updateds[collection] = [_id];
    }
  }

  addDeletedRecordId(collection: string, _id: string) {
    if (this.modifiedRecords.deleteds[collection]) {
      this.modifiedRecords.deleteds[collection].push(_id);
    } else {
      this.modifiedRecords.deleteds[collection] = [_id];
    }
  }

  async getAllTenants(): Promise<UserTenant[]> {
    const results: UserTenant[] = [];
    if (this.getId() != '') {
      const permission: PipelineStage = {
        $lookup: {
          from: 'permission',
          localField: '_id',
          foreignField: 'userId',
          as: 'permissions',
          pipeline: [
            {
              $lookup: {
                from: 'organization',
                localField: 'orgId',
                foreignField: 'orgId',
                as: 'org',
              },
            },
            { $unwind: '$org' },
            {
              $lookup: {
                from: 'branch',
                localField: 'branchId',
                foreignField: 'branchId',
                as: 'branch',
              },
            },
            { $unwind: '$branch' },
          ],
        },
      };
      const pipelines: PipelineStage[] = [
        { $match: { uid: this.uid, tenantId: { $gt: 0 } } },
        {
          $lookup: {
            from: 'tenant',
            localField: 'tenantId',
            foreignField: 'tenantId',
            as: 'tenant',
          },
        },
        permission,
      ];

      const userTenants: Array<
        User & {
          tenant: Tenant[];
          permissions: Array<Permission & { org: Organization; branch: Branch }>;
        }
      > = await this.userModel.aggregate(pipelines);

      if (userTenants) {
        const activeUserTenants = userTenants.filter((userTenant) => {
          return userTenant.active === true && userTenant.tenant[0].active === true;
        });

        activeUserTenants.forEach((activeUserTenant) => {
          const permissions = activeUserTenant.permissions
            .filter((item) => {
              return item.org.active && item.branch.active;
            })
            .map((item) => {
              return {
                _id: item._id,
                orgId: item.orgId,
                branchId: item.branchId,
                groups: item.groups,
                orgRecordId: item.org._id,
                orgCode: item.org.orgCode,
                orgName: item.org.orgName,
                branchCode: item.branch.branchCode,
                branchName: item.branch.branchName,
                xOrg: this.generateXOrg(activeUserTenant.tenantId, item.orgId, item.branchId),
              };
            });

          results.push({
            _id: activeUserTenant._id,
            fullName: activeUserTenant.fullName,
            tenantId: activeUserTenant.tenantId,
            tenantName: activeUserTenant.tenant[0].tenantName,
            permissions: permissions,
          });
        });
      }
    }
    return results;
  }

  setAsStaticUser = (uid: string, uname: string, name: string, email: string, xorg: string) => {
    // Define token info
    this.token = '';
    this.uid = uid;
    this.email = email;
    this.uname = uname;
    this.fullname = name;
    this.ssoACL = {};
    this.roles = [Role.Everyone, Role.User, Role.SuperUser];
    this.setXOrg(xorg);
  };

  setGuestToken(tokenStr: string) {
    const tokeninfo: jwt.JwtPayload = jwt.decode(tokenStr) as jwt.JwtPayload;
    this.guestInfo.uid = tokeninfo?.sub ?? '';
    this.guestInfo.email = <string>tokeninfo?.email ?? '';
    this.guestInfo.uname = <string>tokeninfo?.preferred_username ?? '';
    this.guestInfo.fullname = <string>tokeninfo?.name ?? '';
  }

  getAppIntegration = () => this.appintegration;

  async setAppIntegration() {
    const extension: PipelineStage[] = [
      {
        $match: {
          branchId: this.getBranchId(),
          tenantId: this.getTenantId(),
          active: true,
        },
      },
    ];

    const appintegration = await this.appModel.aggregate(extension);
    if (appintegration && appintegration.length > 0) {
      appintegration.forEach((item) => {
        if (item.appId === 'simbiz6') this.appintegration.simbiz6 = true;
        if (item.appId === 'einvoice') this.appintegration.einvoice = true;
      });
    }
    return this.appintegration;
  }
  /**
   * Define additional properties from user into moreProps
   */
  setMoreProps(userProfile: UserProfile): Record<string, any> {
    const allprops = Object.keys(userProfile);
    const excludekeys = [
      'created',
      'createdBy',
      'updated',
      'updatedBy',
      '_id',
      'email',
      'fullName',
      'permissions',
      'roles',
      'branchCode',
      'branchId',
      'branchName',
      'orgCode',
      'orgId',
      'orgName',
      'timeZone',
      'currency',
      'country',
      'offsetMinute',
      'tenantId',
      'lastActivity',
      'group',
      '__v',
      'uid',
      'orgRecordId',
    ];
    const data: Record<string, any> = {};
    for (let i = 0; i < allprops.length; i++) {
      const key = allprops[i];
      if (!excludekeys.includes(key)) {
        data[key] = userProfile[key];
      }
    }

    if (!data['package']) {
      data['package'] = 'free';
    }
    return data;
  }

  isOnlyExecutive = () => {
    return this.groups.includes(Role.Executive) && this.groups.length == 1;
  };

  offsetDate(date: string): string {
    const timestamp = new Date(date).getTime();
    const offsets = this.getOffsetMinute() * 60000;
    const isodate = new Date(timestamp + offsets).toISOString().split('.')[0] + 'Z';
    return isodate;
  }

  getUserDate(date: string): string {
    const timestamp = new Date(date).getTime();
    const offsets = this.getOffsetMinute() * 60000;
    const isodate = new Date(timestamp + -offsets).toISOString().split('.')[0] + 'Z';
    return isodate;
  }
}

/**
 * Define a type for userinfo
 */
type UserProfile = {
  _id: string;
  uid: string;
  email: string;
  uname: string;
  fullname: string;
  groups: string[];
  roles: Role[];
  tenantRecordId?: string;
  package?: string;
  branchRecordId?: string;
  branchCode?: string;
  branchName?: string;
  orgRecordId?: string;
  orgCode?: string;
  orgName?: string;
  timeZone?: string;
  currency?: string;
  country?: string;
  offsetMinute?: number;
  clientSetting?: TenantClientSetting;
  lastActivity?: string;
  permissions: {
    _id: string;
    tenantId: number;
    orgId: number;
    branchId: number;
    groups: string[];
    currentbranch: {
      _id: string;
      branchCode: string;
      branchName: string;
      active: boolean;
    };
    currentorg: {
      _id: string;
      orgCode: string;
      orgName: string;
      timeZone: string;
      currency: string;
      country: string;
      offsetMinute: number;
      active: boolean;
    };
    currentTenant: {
      _id: string;
      tenantName: string;
      package: string;
      clientSetting: TenantClientSetting;
      owner: {
        uid: string;
      };
      active: boolean;
    };
  };
};

type UserInfo = {
  _id: string;
  sessionId: string;
  tenantId: number;
  orgId: number;
  orgRecordId: string;
  branchRecordId: string;
  branchId: number;
  branchCode: string;
  branchName: string;
  orgCode: string;
  orgName: string;
  timeZone: string;
  currency: string;
  country: string;
  offsetMinute: number;
  email: string;
  uid: string;
  fullName: string;
  groups: string[];
  roles: Role[];
  branches: ProfileUserBranch[];
  invites: ProfileUserInvites[];
  moreProps: Record<string, any>;
};

type UserTenant = User & {
  tenantName: string;
  permissions: Permission[];
};
