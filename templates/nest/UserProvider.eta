import { Injectable, Scope } from '@nestjs/common';
import Base64URL from '@darkwolf/base64url';
import * as jwt from 'jsonwebtoken';
import { Role } from '../roles/roles.enum';
@Injectable({
  scope: Scope.REQUEST,
})
export class UserProvider {
  private static instance: UserProvider;
  protected uid: string = '';
  protected uname: string = '';
  protected email: string = '';
  protected fullname: string = '';
  protected xOrg: string = '';
  protected tenantId: number = 0;
  protected orgId: number = 0;
  protected branchId: number = 0;
  protected accessrights: any = {};
  protected token: string = '';
  protected refreshtoken: string = '';
  protected groups: string[] = [];
  protected roles: Role[] = [Role.SuperUser,Role.User];
  constructor() {}
  public static getInstance(): UserProvider {
    if (!UserProvider.instance) {
      UserProvider.instance = new UserProvider();
    }
    return UserProvider.instance;
  }
  getUid = () => this.uid;
  getUname = () => this.uname;
  getFullname = () => this.fullname;
  getTenantId = () => this.tenantId;
  getOrgId = () => this.orgId;
  getBranchId = () => this.branchId;
  getEmail = () => this.email;
  getGroups = () => this.groups;
  getRoles = () => this.roles;
  setUserToken = (tokenstr: string) => {
    const tokeninfo = jwt.decode(tokenstr);
    // realm_access: {
    //   roles: [
    //     'default-roles-simitdeveloper',
    //     'offline_access',
    //     'uma_authorization'
    //   ]
    // },
    // resource_access: { account: { roles: [Array] } },
    // scope: 'openid email profile',
    // sid: '53192f53-d4af-413b-b8d7-1e186419fe53',
    // email_verified: false,
    // name: 'kstan kstan',
    // preferred_username: 'kstan',
    // given_name: 'kstan',
    // family_name: 'kstan',
    // email: 'kstan@simitgroup.com'

    const u = UserProvider.getInstance();
    u.token = tokenstr;
    u.uid = tokeninfo.sub;
    u.email = tokeninfo.email;
    u.uname = tokeninfo.preferred_username;
    u.fullname = tokeninfo.name;
    u.groups = ['superuser', 'accountant', 'directors'];
    u.accessrights = tokeninfo.resource_access;
  };
  getInfo = () => {
    return UserProvider.getInstance();
  };
  getBranchFilter = () => {
    return {
      tenantId: UserProvider.getInstance().tenantId,
      orgId: UserProvider.getInstance().orgId,
      branchId: UserProvider.getInstance().branchId,
    };
  };
  getTenantFilter = () => {
    return { tenantId: UserProvider.getInstance().tenantId };
  };
  getOrgFilter = () => {
    return {
      tenantId: UserProvider.getInstance().tenantId,
      orgId: UserProvider.getInstance().orgId,
    };
  };
  getWorkflowTaskFilter() {
    return {
      'data.tenantId': UserProvider.getInstance().tenantId,
      'assignments.assignee': UserProvider.getInstance().getUid(),
      // 'assignments.assignee': User.getInstance().getUid(),
    };
  }
  getCreateFilter = () => {
    const u = UserProvider.getInstance();
    return {
      tenantId: u.tenantId,
      orgId: u.orgId,
      branchId: u.branchId,
      createdby: u.uid,
      updatedby: u.uid,
      created: new Date().getTime().toString(),
      updated: new Date().getTime().toString(),
    };
  };
  getUpdateFilter = () => {
    const u = UserProvider.getInstance();
    return {
      updatedby: u.uid,
      updated: new Date().getTime().toString(),
    };
  };
  setXorg = (xorg) => {
    try {
      const decodedText: string = Base64URL.decodeText(xorg);
      const arrXorg = decodedText.split('-');

      if (arrXorg.length == 3) {
        const u = UserProvider.getInstance();
        u.tenantId = Number(arrXorg[0]);
        u.orgId = Number(arrXorg[1]);
        u.branchId = Number(arrXorg[2]);
      } else {
        throw 'invalid x-org';
      }
    } catch (err) {
      throw err;
    }
  };
}
