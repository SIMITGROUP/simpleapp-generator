import { Injectable } from '@nestjs/common';
import { InjectModel } from '@nestjs/mongoose';
import { Model } from 'mongoose';
import Ajv from 'ajv';
import addFormats from 'ajv-formats';

import {
  NotFoundException,
  InternalServerErrorException,
} from '@nestjs/common/exceptions';
@Injectable()
export class SimpleAppService<T extends { _id?: string }> {
  protected jsonschema = { type: 'object', properties: {}, required: [] };
  protected documentIdentityCode='code'
  protected documentIdentityName='label'
  protected LIMITPERPAGE=20
  protected data: T = { _id: '' } as T;
  protected doc: Model<T>;
  protected errorlist = [];
  constructor(newdoc: Model<T>) {
    this.doc = newdoc;
  }
  getRecordId = (): string => this.data._id;
  setSchema = (newschema) => (this.jsonschema = newschema);
  getSchema = () => this.doc.schema.obj;
  getData = () => {
    console.log('thisdata', this.data);
    return this.data;
  };
  setData = (newdata: T) => {
    delete newdata._id;
    this.data = { ...newdata };
    return this;
  };
  async list() {
    try {
      const products = await this.doc.find();
      const productlist = products.map((p: T) => {
        return p;
      });
      //   console.log(products);
      return productlist;
    } catch (err) {
      throw new InternalServerErrorException(err.message);
    }
  }
   async getAutoComplete(keyword: string) {
    try {
      const filter1 = {};
      const filter2 = {};
      filter1[this.documentIdentityCode] = { $regex: keyword };
      filter2[this.documentIdentityName] = { $regex: keyword };
      const filterobj = { $or: [filter1, filter2] };
      const projections = {
        id: `\$_id`,
        label: `\$${this.documentIdentityCode}`,
        name: `\$${this.documentIdentityName}`,
      };
      const products = await this.doc.find(filterobj, projections, {
        limit: this.LIMITPERPAGE,
      });
      const productlist = products.map((p: T) => {
        return p;
      });
      return productlist;
    } catch (err) {
      throw new InternalServerErrorException(err.message);
    }
  }
  async findById(id: string) {
    try {
      console.log('findById', id);
      this.data = await this.doc.findById(id);
      console.log('findById done', this.data);
    } catch (err) {
      //error
      throw new InternalServerErrorException(err.message);
    }

    if (!this.data) {
      //data not found
      throw new NotFoundException('Document Not found:');
    }
    console.log('this.data', this.data);
    return this.data;
    // return this;
  }

  async create() {
    let result;

    try {
      delete this.data._id;
      this.validateData(this.data);
      const newdoc = new this.doc(this.data);
      result = await newdoc.save();
    } catch (err) {
      throw new InternalServerErrorException(err.message);
    }
    return result as T;
  }
  async update() {
    const id: string = this.getRecordId();
    this.findIdThenUpdate(id, this.data);
  }
  async delete() {
    const id: string = this.getRecordId();
    this.findIdThenDelete(id);
  }
  hook(type: string, data: T) {
    return true;
  }
  validateData(data: T) {
    const ajv = new Ajv({ allErrors: true });
    addFormats(ajv);
    ajv.addFormat('field-autocomplete-code', /.*$/)
    ajv.addFormat('field-autocomplete-name', /.*$/)
    ajv.addFormat('autocomplete', /.*$/)
    if (!this.hook('pre-validation', data)) {
      const erromsg: string[] = [];
      for (let i = 0; i < this.errorlist.length; i++) {
        erromsg.push(this.errorlist[i].message);
      }
      throw new InternalServerErrorException(erromsg.join('\n'));
    }
    const validate = ajv.compile(this.jsonschema);
    const valid = validate(data);
    if (!valid) {
      console.log(validate.errors);
      const erromsg: string[] = [];
      for (let i = 0; i < validate.errors.length; i++) {
        erromsg.push(validate.errors[i].message);
      }
      throw new InternalServerErrorException(erromsg.join('\n'));
    }
    this.hook('post-validation', data);
  }

  async findIdThenDelete(id: string) {
    // const data = await this.findById(id);
    try {
      const deleteresult = await this.doc.findByIdAndDelete(id);
      return deleteresult;
    } catch (err) {
      throw new InternalServerErrorException(err.message);
    }
  }

  async findIdThenUpdate(id: string, data: T) {
    // const existingdata = await this.findById(id);

    try {
      console.log('findIdThenUpdate', id);
      this.validateData(data);
      // const result = await existingdata.doc.updateOne(data);
      const result = await this.doc.findByIdAndUpdate(id, data);
      return result;
    } catch (err) {
      throw new InternalServerErrorException(err.message);
    }
  }
}
