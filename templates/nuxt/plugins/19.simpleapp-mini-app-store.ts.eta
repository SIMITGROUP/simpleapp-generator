/**
 * This file was automatically generated by simpleapp generator. Every
 * MODIFICATION OVERRIDE BY GENERATEOR
 * last change 2025-06-09
 */

import _, { min } from "lodash";
import {
  Miniapp,
  MiniAppDetail,
  MiniAppDetailActionAccess,
  MiniappIntegrationPages,
  MINIAPPMANAGERApi,
} from "~/simpleapp/generate/openapi";
import {
  MiniAppFormWithMiniAppCode,
  MiniAppFrameworkCompatibility,
  MiniAppPermissionResult,
} from "~/simpleapp/generate/features/miniApp/app/types/miniApp";

export default defineNuxtPlugin(async () => {
  /**
   * Mini app directory
   */
  const MINI_APP_PAGE_PATH_PREFIX = "miniapp";

  /**
   * To totally block mini app. if mini app's framework compability lower than this.
   * To support backward compatibility, with deprecation notice,
   * if mini app's framework compability higher than this, but lower than MIN_FRAMEWORK_COMPATIBLE_VERSION.
   */
  const MIN_FRAMEWORK_VERSION = "1.0";

  /**
   * The minimum version that is compatible with the current framework.
   */
  const MIN_FRAMEWORK_COMPATIBLE_VERSION = "1.0";

  const config = getAxiosConfig();

  const miniAppManager = new MINIAPPMANAGERApi(config);

  const MINI_APP_BUILT_IN_SETTING_NAME = "mini-app-setting";

  const _ERROR = {
    MISSING_REQUIRED_PLAN: "missingRequiredPlan",
    INSUFFICIENT_ACCESS_PERMISSION: "insufficientAccessPermission",
    INSUFFICIENT_INSTALL_PERMISSION: "insufficientInstallPermission",
    INSUFFICIENT_UNINSTALL_PERMISSION: "insufficientUninstallPermission",
    INSUFFICIENT_CHANGE_SETTING_PERMISSION:
      "insufficientChangeSettingPermission",
    NO_MINI_APP_FEATURE: "packageTypeRestricted",
    NOT_YET_INSTALL: "notYetInstall",
  };

  const useMiniAppStore = defineStore("mini-app", {
    state: () => ({
      actionAccess: {} as MiniAppDetailActionAccess,

      /**
       * Store all installed miniApps
       */
      installedMiniApps: [] as MiniAppDetail[],

      /**
       * Is fetching installed miniApps
       */
      isFetchingInstalledMiniApps: true,
    }),
    getters: {
      getForm: (state) => (formCode: string) => {
        return state.installedMiniApps.flatMap((miniApp) => {
          return miniApp.integration.forms
            .filter((form) => form.code == formCode)
            .map((form) => {
              return {
                ...form,
                miniAppCode: miniApp.code,
              } as MiniAppFormWithMiniAppCode;
            });
        });
      },

      isHaveMiniAppFeature: (state) => {
        if (state.isFetchingInstalledMiniApps) {
          // if still fetching, return true 1st, else will immediate show restricted warning
          return true;
        }

        return state.actionAccess.isHaveMiniAppFeature ?? false;
      },

      isShowMiniAppMoreMenuButton: (state) => {
        const filtered = state.installedMiniApps.filter(
          (item) =>
            item.integration?.pages?.length > 0 ||
            (item.integration?.settings?.jsonSchema &&
              Object.keys(item.integration.settings.jsonSchema).length > 0),
        );

        return _.isEmpty(filtered) ? false : true;
      },

      isCanInstall: (state) => state.actionAccess.isAllowInstall,
      isCanUninstall: (state) => state.actionAccess.isAllowUninstall,
      isCanUpdateSetting: (state) => state.actionAccess.isAllowUpdateSetting,
      isHasMiniAppFeature: (state) => state.actionAccess.isHaveMiniAppFeature,
    },

    actions: {
      getMenuItems() {
        return this.installedMiniApps.flatMap((miniApp) => {
          const pages = miniApp.integration.pages.filter((page) => {
            return (
              this.isAllowAccessMiniAppPage(miniApp.code, page.code) &&
              this.isRequiredToShowOnMenu(page)
            );
          });

          if (this.isCanUpdateSetting) {
            if (
              miniApp.integration.settings?.jsonSchema &&
              !_.isEmpty(miniApp.integration.settings.jsonSchema)
            ) {
              pages.push({
                code: MINI_APP_BUILT_IN_SETTING_NAME,
                title: t("miniAppLang.setting"),
                description: "",
                sourceType: "",
                sources: {
                  development: "",
                  production: "",
                },
                requiredPermissions: [],
                iconType: "class",
                icon: "pi pi-cog",
              });
            }
          }

          // Only return mini app if pages not empty
          if (_.isEmpty(pages)) {
            return [];
          }

          return {
            _id: miniApp._id,
            code: miniApp.code,
            name: miniApp.name,
            logo: miniApp.logo,
            pages,
          };
        });
      },

      isRequiredToShowOnMenu(page: MiniappIntegrationPages) {
        return page.isHideOnMenu !== true;
      },

      // ============================ Load Function ============================
      async loadInstalledMiniApps() {
        this.isFetchingInstalledMiniApps = true;

        const resp = await miniAppManager
          .runGetInstalledMiniApps()
          .then((res) => {
            return res.data;
          })
          .catch((res: any) => {
            return Promise.reject(res);
          });

        this.installedMiniApps = resp.installedMiniApps;
        this.actionAccess = resp.actionAccess;

        this.isFetchingInstalledMiniApps = false;
      },

      async loadMiniAppDetail(miniAppCode: string) {
        return await miniAppManager
          .runGetMiniAppDetail(miniAppCode)
          .then((res) => {
            return res.data;
          })
          .catch((res: any) => {
            return Promise.reject(res);
          });
      },

      async loadCategorizedMiniApps() {
        return await miniAppManager
          .runGetCategorizedMiniApps()
          .then((res) => {
            return res.data;
          })
          .catch((res: any) => {
            return Promise.reject(res);
          });
      },

      // ================================ Permission ===============================

      hasRequiredPlan(miniApp: Miniapp) {
        const currentPlan = getUserProfile().package ?? "";
        const requiredPlans = miniApp.requiredPlans ?? [];
        if (_.isEmpty(requiredPlans)) return true;

        return requiredPlans.includes(currentPlan);
      },

      checkHasFeature() {
        return this._check([
          [() => this.isHasMiniAppFeature, _ERROR.NO_MINI_APP_FEATURE],
        ]);
      },

      checkHasRequiredPlan(miniApp: Miniapp) {
        return this._check([
          [() => this.hasRequiredPlan(miniApp), _ERROR.MISSING_REQUIRED_PLAN],
        ]);
      },

      checkIsInstalled(miniAppCode: string) {
        return this._check([
          [() => this.isMiniAppInstalled(miniAppCode), _ERROR.NOT_YET_INSTALL],
        ]);
      },

      checkCanAccess(miniAppCode: string, pageCode: string) {
        if (pageCode === MINI_APP_BUILT_IN_SETTING_NAME) {
          return this._check([
            [
              () => this.isCanUpdateSetting,
              _ERROR.INSUFFICIENT_ACCESS_PERMISSION,
            ],
          ]);
        }

        return this._check([
          [
            () => this.isAllowAccessMiniAppPage(miniAppCode, pageCode),
            _ERROR.INSUFFICIENT_ACCESS_PERMISSION,
          ],
        ]);
      },

      checkCanInstall(miniApp: Miniapp) {
        return this._check([
          [() => this.hasRequiredPlan(miniApp), _ERROR.MISSING_REQUIRED_PLAN],
          [() => this.isCanInstall, _ERROR.INSUFFICIENT_INSTALL_PERMISSION],
        ]);
      },

      checkCanUninstall(miniApp: Miniapp) {
        return this._check([
          [() => this.isCanUninstall, _ERROR.INSUFFICIENT_UNINSTALL_PERMISSION],
        ]);
      },

      checkCanUpdateSetting(miniApp: Miniapp) {
        return this._check([
          [() => this.hasRequiredPlan(miniApp), _ERROR.MISSING_REQUIRED_PLAN],
          [
            () => this.isCanUpdateSetting,
            _ERROR.INSUFFICIENT_CHANGE_SETTING_PERMISSION,
          ],
        ]);
      },

      _check(checks: [() => boolean, string][]): MiniAppPermissionResult {
        for (const [checkFn, reason] of checks) {
          if (!checkFn()) {
            return { status: false, reason };
          }
        }

        return { status: true };
      },

      // ============================ Path & Navigation ============================

      getMiniAppSettingPath(miniAppCode: string) {
        return `${MINI_APP_PAGE_PATH_PREFIX}/${miniAppCode}/setting`;
      },

      getMiniAppPageUrlPath(miniAppCode: string, pageCode: string): string {
        const page = pageCode === "index" ? "" : "/" + pageCode;
        return `${MINI_APP_PAGE_PATH_PREFIX}/${miniAppCode}/app${page}`;
      },

      getMiniAppPageUrl(
        miniAppCode: string,
        pageCode: string,
        querystr?: string,
      ): string {
        const path = this.getMiniAppPageUrlPath(miniAppCode, pageCode);
        return getDocumentUrl(path, "", querystr);
      },

      getMiniAppSettingPageUrl(miniAppCode: string, querystr?: string): string {
        const path = this.getMiniAppSettingPath(miniAppCode);
        return getDocumentUrl(path, "", querystr);
      },

      navigateToMiniAppInstall(miniAppCode: string) {
        goTo(`integrations/${miniAppCode}`);
      },

      navigateToMiniAppPage(miniAppCode: string, pageCode: string) {
        if (pageCode === MINI_APP_BUILT_IN_SETTING_NAME) {
          goTo(this.getMiniAppSettingPath(miniAppCode));
        } else {
          goTo(this.getMiniAppPageUrlPath(miniAppCode, pageCode));
        }
      },

      // ============================ Validation ============================

      isMiniAppInstalled(miniAppCode: string) {
        const miniApp = this.installedMiniApps.find(
          (item) => item.code === miniAppCode,
        );

        return miniApp ? true : false;
      },

      isAllowAccessMiniAppPage(miniAppCode: string, pageCode: string) {
        const miniApp = this.installedMiniApps.find(
          (item) => item.code === miniAppCode,
        );
        if (!miniApp) {
          return false;
        }

        const page = miniApp.integration.pages.find(
          (item) => item.code === pageCode,
        );
        if (!page) {
          return false;
        }

        if (checkHasHighPrivilege()) {
          return true;
        }

        const userRoles = getUserProfile().roles;

        if (page.requiredPermissions && !_.isEmpty(page.requiredPermissions)) {
          return page.requiredPermissions.some((permission) =>
            userRoles.includes(permission),
          );
        }
        return true;
      },

      getPageInfo(miniApp: Miniapp, pageCode: string) {
        return miniApp.integration.pages.find((item) => item.code === pageCode);
      },

      checkMiniAppFrameworkCompatibility: (
        miniApp: Miniapp,
      ): MiniAppFrameworkCompatibility => {
        if (miniApp.frameworkCompatibility < MIN_FRAMEWORK_VERSION) {
          return MiniAppFrameworkCompatibility.DEPRECATED;
        }

        if (miniApp.frameworkCompatibility < MIN_FRAMEWORK_COMPATIBLE_VERSION) {
          return MiniAppFrameworkCompatibility.TO_BE_DEPRECATED;
        }

        return MiniAppFrameworkCompatibility.COMPATIBLE;
      },

      // ============================ miniApp Action ============================

      async installMiniApp(miniAppCode: string) {
        const miniAppInstallation = await miniAppManager
          .runInstallMiniApp(miniAppCode)
          .then((res) => {
            return res.data;
          })
          .catch((res: any) => {
            return Promise.reject(res);
          });

        this.loadInstalledMiniApps();

        return miniAppInstallation;
      },

      async uninstallMiniApp(miniAppCode: string) {
        const miniAppInstallation = await miniAppManager
          .runUninstallMiniApp(miniAppCode)
          .then((res) => {
            return res.data;
          })
          .catch((res: any) => {
            return Promise.reject(res);
          });

        this.loadInstalledMiniApps();

        return miniAppInstallation;
      },

      async updateMiniAppSetting(
        miniAppCode: string,
        data: { [key: string]: any },
      ) {
        const miniAppInstallation = await miniAppManager
          .runUpdateMiniAppSetting(miniAppCode, data)
          .then((res) => {
            return res.data;
            ``;
          })
          .catch((res: any) => {
            return Promise.reject(res);
          });

        this.loadInstalledMiniApps();

        return miniAppInstallation;
      },

      openMiniAppSetting(miniAppCode: string | undefined) {
        if (miniAppCode && miniAppCode != "") {
          this.navigateToMiniAppPage(
            miniAppCode,
            MINI_APP_BUILT_IN_SETTING_NAME,
          );
        }
      },
    },
  });

  return {
    provide: {
      miniAppStore: useMiniAppStore(),
    },
  };
});
