/**
 * This file was automatically generated by simpleapp generator. Every
 * MODIFICATION OVERRIDE BY GENERATEOR
 * last change 2023-10-28
 * Author: Ks Tan
 */
import { defineNuxtPlugin } from "#app";
import {PROFILEApi} from '../simpleapp/generate/openapi'
import axios, { Axios, AxiosResponse } from 'axios'
import _ from 'lodash'


export default defineNuxtPlugin( async(nuxtApp) => {


    const useUserStore = defineStore('userstore', {
        state: ()=>({        
          sessionId:ref(''),
          tenantId:ref(0),
          orgId:ref(0),
          branchId:ref(0),
          branchCode:ref(''),
          branchName:ref(''),
          orgCode:ref(''),
          orgName:ref(''),
          uid: ref(''),
          email: ref(''),
          fullName: ref(''),
          roles:ref<string[]>([]),
          group:ref(''),
          branches:ref([]),
          invites : ref([]),
          time:ref('')
        }),
        
        actions:{    
          async loadRemoteUserInfo(){
            console.log('loadRemoteUserInfo')
            const {$axios} = useNuxtApp()
            const route = useRoute();
            let xorg = route.params.xorg
            let apiurl=''
            if(xorg===undefined){
              apiurl = `${useRuntimeConfig().public.APP_URL}/api`
            }else{
              apiurl = `${useRuntimeConfig().public.APP_URL}/api/${xorg}`
            }
            
            return await new PROFILEApi(undefined,apiurl,$axios).getProfile().then((res:AxiosResponse)=>{            
              if(!res){
                return
              }
              this.sessionId = res.data.sessionId
              this.tenantId = res.data.tenantId              
              this.orgId = res.data.orgId
              this.branchId = res.data.branchId
              this.branchCode = res.data.branchCode
              this.branchName = res.data.branchName
              this.orgCode = res.data.orgCode
              this.orgName = res.data.orgName
              this.uid = res.data.uid
              this.email = res.data.email
              this.fullName = res.data.fullName              
              this.branches = res.data.branches
              this.group = res.data.group
              this.roles = res.data.roles
              this.time = res.data.time              
              this.invites = res.data.invites
              
              return Promise.resolve(true)
                // return true
            }).catch((err:any)=>{
              if(err.response=== undefined){
                // console.error("no backend server")
                const errdata = createError({statusCode:503,statusMessage:"Backend server timeout, verify it is up and running!"})
                return Promise.reject(errdata)
              }
              else if(err.response && err.response.status==401){
                console.error("Unauthorise(plugin-userstore)")
              }else{
                const errdata = createError({statusCode:500,statusMessage:"Unknown error"})                
                return Promise.reject(errdata)
              }
            })            
          },
          getAvatarLink(size:number){
            return `https://i.pravatar.cc/${size}`
          },
          getCurrentXorg(){
            const currentxorg:string = String(useRoute().params.xorg)
            return currentxorg //_.find(this.branches,{xorg:currentxorg})
          },
          async decideInvitation(id:string,decision:string){
            const apiurl = `${useRuntimeConfig().public.APP_URL}/api`
            const {$axios} = useNuxtApp()
            console.log("decideInvitation",id,decision)
            const result = await new PROFILEApi(undefined,apiurl,$axios).decideInvitation(id,decision)
            
            if(result){
              console.log(result)
            }else{
              console.log(result)
            }
            //().then((res:AxiosResponse)=>{ }
          },
          canPerform(resourcename:string,action:string):boolean{

            if(
              this.roles.includes('superadmin') ||
              this.roles.includes('tenantowner') ||
              this.roles.includes('superuser') 
              ){
              return true
            }else{
              const checkstr= `${resourcename}:${action}`
              // console.log("verify",checkstr)
              return this.roles.includes(checkstr)
            }
          },
          haveAccess(resourcename:string){          
            //super admin always full access right
            resourcename = _.upperFirst(resourcename)
            // console.log("have access",resourcename)
            if(
              this.roles.includes('superadmin') ||
              this.roles.includes('tenantowner') ||
              this.roles.includes('superuser') 
              ){
              return true
            }
            for(let i=0; i< this.roles.length; i++){
            const role:string = this.roles[i]
             if(role.includes(resourcename)){
                return true
              }
            }
            return false                        
          },
          getUserInfo(){
            return {
              sessionId : this.sessionId,
              tenantId : this.tenantId,
              orgId : this.orgId,
              branchId : this.branchId,
              uid : this.uid,
              email : this.email,
              branchCode: this.branchCode,
              branchName: this.branchName,
              orgCode: this.orgCode,
              orgName: this.orgName,
              fullName : this.fullName,        
              branches:this.branches??[],
              invites: this.invites ?? [],
              roles:this.roles,
              group:this.group,
              time:this.time,
              currentxorg: this.getCurrentXorg()
  
              
            }
          }
        }        
      })

      const route = useRoute();      
      
      if(route.meta.auth !==false){
        await useUserStore().loadRemoteUserInfo()
      }
    
    return {

        
        provide: {
            userstore:useUserStore()
          // base64url: Base64URL
        }
    }
    
});
