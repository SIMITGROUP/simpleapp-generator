/**
 * This file was automatically generated by simpleapp generator. Every
 * MODIFICATION OVERRIDE BY GENERATEOR
 * last change 2024-02-23
 * Author: Ks Tan
 */
import { NuxtAuthHandler } from "#auth";
import KeycloakProvider from "next-auth/providers/keycloak";
// import GithubProvider from "next-auth/providers/github";

export default NuxtAuthHandler({
    secret: process.env.AUTH_SECRET_KEY,
    jwt: {
        maxAge: 60 * 60 * 24 * 30,
    },
    providers: [
        // GithubProvider.default({
        //     clientId: process.env.GITHUB_ID ?? '',
        //     clientSecret: process.env.GITHUB_SECRET ?? '',
        // }),
        // @ts-expect-error
        KeycloakProvider.default({
            clientId: process.env.OAUTH2_CLIENTID ?? "",
            clientSecret: process.env.OAUTH2_CLIENTSECRET ?? "",
            issuer: process.env.OAUTH2_CONFIGURL,
            idToken: true,
            scheme: "oauth2",
            endpoints: {
                authorization: `${process.env.OAUTH2_CONFIGURL}/protocol/openid-connect/auth`,
                userInfo: `${process.env.OAUTH2_CONFIGURL}/protocol/openid-connect/userinfo`,
                token: `${process.env.OAUTH2_CONFIGURL}/protocol/openid-connect/token`,
                logout:
                    `${process.env.OAUTH2_CONFIGURL}/protocol/openid-connect/logout?redirect_uri=` +
                    encodeURIComponent(String(process.env.NUXT_PUBLIC_API_BASE)),
            },
            // accessTokenUrl: `${process.env.OAUTH2_CONFIGURL}/protocol/openid-connect/token`,
            // requestTokenUrl: `${process.env.OAUTH2_CONFIGURL}/protocol/openid-connect/token`,
            // profileUrl: `${process.env.OAUTH2_CONFIGURL}/protocol/openid-connect/userinfo`,
            token: {
                property: "access_token",
                type: "Bearer",
                name: "Authorization",
                maxAge: 60 * 60 * 24,
            },
            refreshToken: {
                property: "refresh_token",
                maxAge: 60 * 60 * 24 * 30,
            },
            responseType: "code",
            grantType: "authorization_code",
            scope: ["openid", "profile", "email"],
            codeChallengeMethod: "S256",
            redirect: {
                logout: "/",
                // callback: "/",
                // home: "/",
            },
        }),
    ],
    pages: {
        signIn: "/login",
    },
    callbacks: {
        // async redirect({ url, baseUrl }) {

        //     console.log(url, baseUrl)
        //     return baseUrl
        // },
        async jwt({ token, account }) {
            // Persist the OAuth access_token to the token right after signin
            if (account) {
                token.accessToken = account.access_token;
                token.refreshToken = account.refresh_token;
                token.expiresAt = account.expires_at;
            } else if (Date.now() < (<number>token.expiresAt) * 1000) {
                return token;
            }

            // try refresh token
            const response = await fetch(`${process.env.OAUTH2_CONFIGURL}/protocol/openid-connect/token`, {
                headers: { "Content-Type": "application/x-www-form-urlencoded" },
                body: new URLSearchParams({
                    client_id: process.env.OAUTH2_CLIENTID ?? "",
                    client_secret: process.env.OAUTH2_CLIENTSECRET ?? "",
                    grant_type: "refresh_token",
                    refresh_token: <string>token.refreshToken ?? "",
                }),
                method: "POST",
            })

            const newToken = await response.json();

            if(!response.ok) {
                /** @todo handle refresh token failed */
                return token
            }

            return {
                ...token,
                accessToken: newToken.access_token,
                // record next access token expires time
                expiresAt: Math.floor(Date.now() / 1000 + newToken.expires_in),
                // Fall back to old refresh token, but note that
                // many providers may only allow using a refresh token once.
                refreshToken: newToken.refresh_token ?? token.refresh_token,
            }
        },
        async session({ session, token, user }) {
            // console.log("session", session);
            // Send properties to the client, like an access_token from a provider.
            const sessiondata:any = {...session}
            sessiondata.accessToken = <string>token.accessToken;
            return sessiondata;
        },
    },
});