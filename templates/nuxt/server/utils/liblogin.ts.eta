/**
 * This file was automatically generated by simpleapp generator. Every
 * MODIFICATION OVERRIDE BY GENERATEOR
 * last change 2025-03-16
 * Author: Ks Tan
 */
import * as crypto from 'crypto';
import { z } from 'zod'

const algorithm = 'aes-256-cbc';
const key = process.env.NUXT_SESSION_PASSWORD ?? '12345678901234567890123456789032'
const serverurl = (process.env.SIMPLEAPP_BACKEND_URL ?? 'http://localhost:8000').replace(/\/$/, '')
const bodySchema = z.object({
  uname: z.string(),
  password: z.string().min(8)
})

export const getServerUrl = ()=>serverurl
export const generateSymmetryRandomIv =()=> crypto.randomBytes(8).toString('hex');
export const symmetryEncrypt = (text: string,iv:string): string => {
  const cipher = crypto.createCipheriv(algorithm, key, iv);
  let encrypted = cipher.update(text, 'utf-8', 'hex');
  encrypted += cipher.final('hex');
  return encrypted;
}

export const symmetryDecrypt = (encryptedText: string,iv:string): string =>{
  const decipher = crypto.createDecipheriv(algorithm, key, iv);
  let decrypted = decipher.update(encryptedText, 'hex', 'utf-8');
  decrypted += decipher.final('utf-8');
  return decrypted;
}


export const saveToken = async (name:string,event:any, data:any)=>{
  const access_token = data['access_token'] ?? ''
  const expires_in = data['expires_in'] ?? 0
  const refresh_token = data['refresh_token'] ?? ''
  const refresh_expires_in = data['refresh_expires_in'] ?? 0
  const iv = generateSymmetryRandomIv()
  const encryptedRefreshToken = symmetryEncrypt(refresh_token,iv)  
  
  setCookie(event, 'refresh_token', encryptedRefreshToken
  , { httpOnly: true, maxAge: 8 * 60 * 60 })
  setCookie(event, 'refresh_expires_in', refresh_expires_in, {
  httpOnly: true,
  maxAge: 8 * 60 * 60,
  })

  await setUserSession(event, {
  user: {
      name: name,
      email: data['email']
  },
  secure: {
      access_token: access_token,
      expires_in: expires_in,    
      iv: iv
  },
  loggedInAt: new Date()
  }) 
}


export const loginUser = async (event:any)=>{

  const { uname, password } = await readValidatedBody(event, bodySchema.parse)
  try {

    const serverurl = process.env.SIMPLEAPP_BACKEND_URL ?? 'http://localhost:8000'
    const data: any = await $fetch(serverurl + '/profile/login', {
      method: 'post',
      body: { "user": uname, "password": password },//credentialdata,  
      headers: {
        'content-type': 'application/json'
      },
    })

    if (data['access_token']) {
      await saveToken(uname,event,data)
      return data
    }

  } catch (err) {    
    throw createError({
      statusCode: 401,
      message: 'Bad credentials',
      data: err
    })
  }
}
async function renewToken(event:any,refreshtoken:string){
  const session = await requireUserSession(event)
  try{
      const lastIv = session?.secure?.iv ??''      
      const data:any = await $fetch(serverurl + '/profile/renew-token', {
          method: 'post',
          'content-type': 'text/plain',
          body:{ "refreshToken": symmetryDecrypt(refreshtoken,lastIv) },            
        })
        
       return data
  }catch(err){
      throw createError({ statusText: 'Unauthorized', status: 401 })
  }   


}

export const logoutUser = async(event:any,session:any,refresh_token:string)=>{            
  // revoke refresh token will also revoke access token from sso server  
  const logoutUrl = serverurl+ '/profile/logout'
  
  try{
      await clearUserSession(event)
      setCookie(event, 'refresh_token', ''
          , { httpOnly: true, maxAge:0})
      setCookie(event, 'refresh_expires_in','0', {
          httpOnly: true,
          maxAge: 0,
      })
      const response = await $fetch(logoutUrl, {
          method: 'post',
          headers: {
            'content-type': 'application/json',
          },
          body:{ "refreshToken": symmetryDecrypt(refresh_token,session.secure.iv) },
        }) 

        
      return true
  }catch(err){      
      return false
  }
 
}

export const getAccessToken = async(event:any,session:any)=>{ 
  const accessToken:string = session.secure.accessToken
  const name:string = session.user.name
  const currentTime = new Date()
  const tokenExpiredTime = new Date(session.secure.expires_in)    
  const strRefreshTokenExpired = parseInt( getCookie(event,'refresh_expires_in') ?? '0')
  const refreshTokenExpiredTime = new Date(strRefreshTokenExpired) 

  //no session exists
  if(!session.id || session.id=='' || currentTime >= refreshTokenExpiredTime){        
      throw createError({ statusText: 'Unauthorized', status: 401 })
  }
  else if(tokenExpiredTime < currentTime && refreshTokenExpiredTime > currentTime ){     
      //refresh the token if required
      try{
          const refreshtoken = getCookie(event,'refresh_token') ??''
          const data = await renewToken(event,refreshtoken)
           
          await saveToken(name,event,data)
          
          return new Promise<string>(async(resolve, reject)=>{
            if(data.access_token){
              resolve(data.access_token)   
            }else{
              reject({ statusText: 'Renewed token empty!', status: 500 })
            }
              
          })
      }catch(error){            
          throw createError({ statusText: 'Unauthorized', status: 401 })
      }
  }else{    
    return new Promise<string>(async(resolve, reject)=>{
      resolve(session.secure.access_token)
    })
      
    //  }   // 
  }
} 