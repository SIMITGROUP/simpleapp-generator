import { NuxtAuthHandler } from "#auth";
import KeycloakProvider from "next-auth/providers/keycloak";
import type { JWT } from "next-auth/jwt";
// import GithubProvider from "next-auth/providers/github";

export default NuxtAuthHandler({
    secret: process.env.AUTH_SECRET_KEY,
    jwt: {
        maxAge: 60 * 60 * 24 * 30,
    },
    providers: [
        // GithubProvider.default({
        //     clientId: process.env.GITHUB_ID ?? '',
        //     clientSecret: process.env.GITHUB_SECRET ?? '',
        // }),
        // @ts-expect-error
        KeycloakProvider.default({
            clientId: process.env.OAUTH2_CLIENTID ?? "",
            clientSecret: process.env.OAUTH2_CLIENTSECRET ?? "",
            issuer: process.env.OAUTH2_CONFIGURL,
            idToken: true,
            scheme: "oauth2",
            endpoints: {
                authorization: `${process.env.OAUTH2_CONFIGURL}/protocol/openid-connect/auth`,
                userInfo: `${process.env.OAUTH2_CONFIGURL}/protocol/openid-connect/userinfo`,
                token: `${process.env.OAUTH2_CONFIGURL}/protocol/openid-connect/token`,
                logout:
                    `${process.env.OAUTH2_CONFIGURL}/protocol/openid-connect/logout?redirect_uri=` +
                    encodeURIComponent(String(process.env.APP_URL)),
            },
            // accessTokenUrl: `${process.env.OAUTH2_CONFIGURL}/protocol/openid-connect/token`,
            // requestTokenUrl: `${process.env.OAUTH2_CONFIGURL}/protocol/openid-connect/token`,
            // profileUrl: `${process.env.OAUTH2_CONFIGURL}/protocol/openid-connect/userinfo`,
            token: {
                property: "access_token",
                type: "Bearer",
                name: "Authorization",
                maxAge: 60 * 60 * 24,
            },
            refreshToken: {
                property: "refresh_token",
                maxAge: 60 * 60 * 24 * 30,
            },
            responseType: "code",
            grantType: "authorization_code",
            scope: ["openid", "profile", "email"],
            codeChallengeMethod: "S256",
            redirect: {
                logout: "/",
                callback: "/",
                home: "/",
            },
        }),
    ],
    pages: {
        signIn: "/login",
    },
    callbacks: {
        // async redirect({ url, baseUrl }) {

        //     console.log(url, baseUrl)
        //     return baseUrl
        // },
        async jwt({ token, account }) {
            // Persist the OAuth access_token to the token right after signin
            if (account) {
                token.accessToken = account.access_token;
            }
            return token;
        },
        async session({ session, token, user }) {
            // console.log("session", session);
            // Send properties to the client, like an access_token from a provider.
            session.accessToken = <string>token.accessToken;
            return session;
        },

        /*async jwt({ token, account, user }) {
            // Persist the OAuth access_token to the token right after signin
            console.log("token", token);
            console.log("account", account);
            console.log("user", user);

            // Initial sign in
            if (account && user) {
                // Add access_token, refresh_token and expirations to the token right after signin
                token.accessToken = account.accessToken;
                token.refreshToken = account.refreshToken;
                token.accessTokenExpired =
                    Date.now() + (account.expires_in - 15) * 1000;
                token.refreshTokenExpired =
                    Date.now() + (account.refresh_expires_in - 15) * 1000;
                token.user = user;
                return token;
            }

            // Return previous token if the access token has not expired yet
            if (Date.now() < token.accessTokenExpired) return token;

            // Access token has expired, try to update it
            return refreshAccessToken(token);

            // if (account) {
            //     // Save the access token and refresh token in the JWT on the initial login
            //     token.accessToken = account.access_token;
            //     return {
            //         access_token: account.access_token,
            //         expires_at: Math.floor(
            //             Date.now() / 1000 + account.expires_in
            //         ),
            //         refresh_token: account.refresh_token,
            //     };
            // } else if (Date.now() < token.expires_at * 1000) {
            //     // If the access token has not expired yet, return it
            //     return token;
            // } else {
            //     // If the access token has expired, try to refresh it
            //     try {
            //         // ${process.env.OAUTH2_CONFIGURL}/.well-known/openid-configuration
            //         // We need the `token_endpoint`.
            //         const response = await fetch(
            //             `${process.env.OAUTH2_CONFIGURL}/protocol/openid-connect/token`,
            //             {
            //                 headers: {
            //                     "Content-Type":
            //                         "application/x-www-form-urlencoded;charset=UTF-8",
            //                 },
            //                 body: new URLSearchParams({
            //                     client_id: process.env.OAUTH2_CLIENTID ?? "",
            //                     client_secret:
            //                         process.env.OAUTH2_CLIENTSECRET ?? "",
            //                     grant_type: "refresh_token",
            //                     refresh_token: <string>token.refresh_token,
            //                 }),
            //                 method: "POST",
            //             }
            //         );

            //         const tokens: any = await response.json();

            //         if (!response.ok) throw tokens;

            //         return {
            //             ...token, // Keep the previous token properties
            //             access_token: tokens.access_token,
            //             expires_at: Math.floor(
            //                 Date.now() / 1000 + tokens.expires_in
            //             ),
            //             // Fall back to old refresh token, but note that
            //             // many providers may only allow using a refresh token once.
            //             refresh_token:
            //                 tokens.refresh_token ?? token.refresh_token,
            //         };
            //     } catch (error) {
            //         console.error("Error refreshing access token", error);
            //         // The error property will be used client-side to handle the refresh token error
            //         return {
            //             ...token,
            //             error: "RefreshAccessTokenError" as const,
            //         };
            //     }
            // }
            return token;
        },
        async session({ session, token, user }) {
            if (token) {
                session.error = <string>token.error;
                session.accessToken = <string>token.accessToken;
            }
            return session;
        }, */
    },
});

/* const refreshAccessToken = async (token: JWT) => {
    try {
        if (Date.now() > token.refreshTokenExpired) throw Error;
        const details = {
            client_id: process.env.OAUTH2_CLIENTID,
            client_secret: process.env.OAUTH2_CLIENTSECRET,
            grant_type: ["refresh_token"],
            refresh_token: token.refreshToken,
        };
        const formBody: string[] = [];
        Object.entries(details).forEach(([key, value]: [string, any]) => {
            const encodedKey = encodeURIComponent(key);
            const encodedValue = encodeURIComponent(value);
            formBody.push(encodedKey + "=" + encodedValue);
        });
        const formData = formBody.join("&");
        const url = `${process.env.OAUTH2_CONFIGURL}/protocol/openid-connect/token`;
        const response = await fetch(url, {
            method: "POST",
            headers: {
                "Content-Type":
                    "application/x-www-form-urlencoded;charset=UTF-8",
            },
            body: formData,
        });
        const refreshedTokens = await response.json();
        if (!response.ok) throw refreshedTokens;
        return {
            ...token,
            accessToken: refreshedTokens.access_token,
            accessTokenExpired:
                Date.now() + (refreshedTokens.expires_in - 15) * 1000,
            refreshToken: refreshedTokens.refresh_token ?? token.refreshToken,
            refreshTokenExpired:
                Date.now() + (refreshedTokens.refresh_expires_in - 15) * 1000,
        };
    } catch (error) {
        console.log('receive', error)

        return {
            ...token,
            error: "RefreshAccessTokenError",
        };
    }
}; */

// import NextAuth from "next-auth"
// import KeycloakProvider from 'next-auth/providers/keycloak'
// export const authOptions = {
//   // Configure one or more authentication providers
//   providers: [
//     KeycloakProvider({
//         clientId: process.env.OAUTH2_CLIENTID,
//             clientSecret: process.env.OAUTH2_CLIENTSECRET,
//             issuer: process.env.OAUTH2_CONFIGURL,
//     }),
//   ],
// }
// export default NextAuth(authOptions)