/**
 * This file was automatically generated by simpleapp generator. Every
 * MODIFICATION OVERRIDE BY GENERATEOR
 * last change 2025-06-09
 */
import _ from "lodash";
import {
  CustomFieldJsonSchemaMoreSchema,
  CustomFieldJsonSchemaMoreSchemaGroup,
  DynamicObject,
  SimpleAppJSONSchema7Definition,
} from "~/types";

export class SimpleAppCustomFieldClient {
  constructor() {}

  formCustomFieldJsonSchema(collectionName: string) {
    const customFieldFromDB = this._findCustomFieldSchemaFromDB(collectionName);
    const customFieldFromPlugin =
      this._findCustomFieldSchemaFromPlugin(collectionName);

    if (customFieldFromDB && !_.isEmpty(customFieldFromDB)) {
    }

    const schema: CustomFieldJsonSchemaMoreSchema = {
      type: "object",
      properties: {
        ...customFieldFromDB,
        ...customFieldFromPlugin,
      },
    };

    return schema;
  }

  private _findCustomFieldSchemaFromDB(collectionName: string) {
    const { $customFieldStore } = useNuxtApp();
    if (!$customFieldStore.data || _.isEmpty($customFieldStore.data)) {
      return {};
    }

    const customField = $customFieldStore.findByCollectionName(collectionName);
    if (!customField) {
      return {};
    }

    const schema: CustomFieldJsonSchemaMoreSchemaGroup = {
      default: {
        title: "Custom Field",
        ...customField.form.schema,
      },
    };

    return schema;
  }

  private _findCustomFieldSchemaFromPlugin(collectionName: string) {
    const schema: CustomFieldJsonSchemaMoreSchemaGroup = {};

    const { $appPluginsStore } = useNuxtApp();

    const pluginForms = $appPluginsStore.getForm(collectionName);
    if (!pluginForms || pluginForms.length <= 0) {
      return schema;
    }

    for (let i = 0; i < pluginForms.length; i++) {
      const pluginItem = pluginForms[i];
      const { pluginCode, jsonSchema } = pluginItem;

      schema[pluginCode] = jsonSchema as SimpleAppJSONSchema7Definition;
    }

    return schema;
  }

  formCustomFieldData(
    collectionName: string,
    moreSchema: CustomFieldJsonSchemaMoreSchema | undefined,
    isNew: boolean,
    resourceData: any | undefined,
  ) {
    if (!moreSchema || !moreSchema?.properties) {
      return resourceData;
    }

    if (collectionName !== "religion") {
      return resourceData;
    }

    const data: DynamicObject = {};

    if (!isNew) {
      for (const [groupName, groupItem] of Object.entries(
        moreSchema.properties,
      )) {
        const defaultData = this.generateDefaultData(groupItem);
        const mergedData = this.mergeWithDefault(
          defaultData,
          resourceData?.[groupName],
        );

        data[groupName] = mergedData;
      }
    } else {
      for (const [groupName, groupItem] of Object.entries(
        moreSchema.properties,
      )) {
        const defaultData = this.generateDefaultData(groupItem);

        data[groupName] = defaultData;
      }
    }

    return data;
  }

  generateDefaultData(schema: any): any {
    if (schema.type === "object") {
      const result: any = {};
      if (schema?.["x-foreignkey"]) {
        return undefined;
      }

      const properties = schema.properties || {};
      for (const key of Object.keys(properties)) {
        result[key] = this.generateDefaultData(properties[key]);
      }
      return result;
    }

    if (schema.type === "array") {
      const itemSchema = schema.items;
      const minItems = schema.minItems || 0;
      const arr = [];
      const itemsCount = minItems > 0 ? 1 : 0;
      for (let i = 0; i < itemsCount; i++) {
        arr.push(this.generateDefaultData(itemSchema));
      }
      return arr;
    }

    if (typeof schema.default !== "undefined") {
      return schema.default;
    }

    // handle primitive types fallback
    switch (schema.type) {
      case "string":
        return "";
      case "number":
      case "integer":
        return 0;
      case "boolean":
        return false;
      default:
        return null;
    }
  }

  mergeWithDefault(defaultData: any, dbData: any): any {
    if (Array.isArray(defaultData)) {
      if (Array.isArray(dbData)) {
        if (_.isEmpty(dbData)) {
          return [];
        }
        // Merge each item
        const mergedArray = dbData.map((dbItem, index) => {
          const defaultItem = defaultData[index] ?? defaultData[0]; // use first default if index out of bound
          return this.mergeWithDefault(defaultItem, dbItem);
        });
        return mergedArray;
      } else {
        // return defaultData;
        return [];
      }
    } else if (typeof defaultData === "object" && defaultData !== null) {
      const result: any = {};
      for (const key of Object.keys(defaultData)) {
        result[key] = this.mergeWithDefault(defaultData[key], dbData?.[key]);
      }
      return result;
    } else {
      // primitive value
      return typeof dbData !== "undefined" ? dbData : defaultData;
    }
  }
}
