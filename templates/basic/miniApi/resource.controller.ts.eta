<%
  const pascalName = upperFirstCase(it.resourceName);
  const kebabName = camelToKebab(it.resourceName);
  const apiName = it.typename.toUpperCase() + 'Api';
  const titleName = titleCase(pascalName);
  const uglyName = upperFirstCase(it.name ?? '');
  const schemaName = `SimtrainSchema.${uglyName}`;
  const schemaAutoCompleteName = `SimtrainSchema.${uglyName}AutoComplete`;

  const serviceVariable = it.resourceName + 'Service';

  const getTypeName = (typeName) => {
    const systemTypes = ['boolean', 'string', 'number', 'object', 'integer'];
    let tmpTypeName = typeName.replace('[','').replace(']','');

    if(systemTypes.includes(tmpTypeName.toLowerCase())){
        tmpTypeName = upperFirstCase(tmpTypeName.toLowerCase());
    } else {
        tmpTypeName = `SimtrainSchema.${tmpTypeName}`;
    }

    if(typeName.includes('[')){
        return `[${tmpTypeName}]`;
    }

    return tmpTypeName;
  }
%>

import {
  Controller,
  Get,
  Post,
  Body,
  Put,
  Patch,
  Param,
  Delete,
  Headers,
  Query,
} from '@nestjs/common';
import { ApiTags, ApiBody, ApiResponse, ApiOperation, ApiQuery, PartialType } from '@nestjs/swagger';
import { ApiHeader } from 'src/types/api';
import { <%= pascalName %>Service } from './<%= kebabName %>.service';
import { ResourceApiListDto } from '../../dto/resource-api.schema';
import * as SimtrainSchema from '../../simtrain-schema';
import { Filter } from 'mongodb';

@ApiTags('<%= titleName %>')
@Controller('resources/<%= kebabName %>')
export class <%= pascalName %>Controller {
    constructor(private readonly <%= serviceVariable %>: <%= pascalName %>Service) {}

    <% Object.entries(it.miniApp.whitelistApis).forEach(([action, value]) => { %>
        <% if (value !== true && typeof value !== 'object') { return; } %>

        <% if(action === 'list') { %>
            @Post('list')
            @ApiOperation({ operationId: 'list' })
            @ApiBody({ type: ResourceApiListDto<<%= schemaName %>>, required: false })
            @ApiResponse({ status: 200, description: 'Success', type: [<%= schemaName %>] })
            @ApiResponse({ status: 400, description: 'Bad Request' })
            @ApiResponse({ status: 500, description: 'Internal Error' })
            async findAll(@Headers() headers:ApiHeader, @Body() dto?: ResourceApiListDto<<%= schemaName %>>) {
                return await this.<%= serviceVariable %>.findAll(headers, dto);
            }
        <% } else if(action === 'detail') { %>
            @Get(':id')
            @ApiOperation({ operationId: 'detail' })
            @ApiResponse({ status: 200, description: 'Success', type: <%= schemaName %> })
            @ApiResponse({ status: 404, description: 'Not Found' })
            @ApiResponse({ status: 500, description: 'Internal Error' })
            async findOne(@Headers() headers: ApiHeader, @Param('id') id: string) {
                return await this.<%= serviceVariable %>.findOne(headers, id);
            }
        <% } else if(action === 'create') { %>
            @Post()
            @ApiOperation({ operationId: 'create' })
            @ApiBody({ type: <%= schemaName %>, required: true })
            @ApiResponse({ status: 200, description: 'Success', type: <%= schemaName %> })
            @ApiResponse({ status: 400, description: 'Bad Request' })
            @ApiResponse({ status: 500, description: 'Internal Error' })
            async create(
                @Headers() headers: ApiHeader,
                @Body() resourceDto: any,
            ) {
                return await this.<%= serviceVariable %>.create(headers, resourceDto);
            }
        <% } else if(action === 'update') { %>
            @Put(':id')
            @ApiOperation({ operationId: 'update' })
            @ApiBody({ type: <%= schemaName %>, required: true })
            @ApiResponse({ status: 200, description: 'Success', type: <%= schemaName %> })
            @ApiResponse({ status: 400, description: 'Bad Request' })
            @ApiResponse({ status: 404, description: 'Not Found' })
            @ApiResponse({ status: 500, description: 'Internal Error' })
            async update(
                @Headers() headers: ApiHeader,
                @Param('id') id: string,
                @Body() resourceDto: any,
            ) {
                return await this.<%= serviceVariable %>.update(headers, id, resourceDto);
            }
        <% } else if(action === 'patch') { %>
            @Patch(':id')
            @ApiOperation({ operationId: 'patch' })
            @ApiBody({ type: PartialType(<%= schemaName %>), required: true })
            @ApiResponse({ status: 200, description: 'Success', type: <%= schemaName %> })
            @ApiResponse({ status: 400, description: 'Bad Request' })
            @ApiResponse({ status: 404, description: 'Not Found' })
            @ApiResponse({ status: 500, description: 'Internal Error' })
            async patch(
                @Headers() headers: ApiHeader,
                @Param('id') id: string,
                @Body() resourceDto: any,
            ) {
                return await  this.<%= serviceVariable %>.patch(headers, id, resourceDto);
            }
        <% } else if(action === 'delete') { %>
            @Delete(':id')
            @ApiOperation({ operationId: 'delete' })
            @ApiResponse({ status: 200, description: 'Success', type: <%= schemaName %> })
            @ApiResponse({ status: 400, description: 'Bad Request' })
            @ApiResponse({ status: 404, description: 'Not Found' })
            @ApiResponse({ status: 500, description: 'Internal Error' })
            async delete(
                @Headers() headers: ApiHeader,
                @Param('id') id: string,
            ) {
                return await this.<%= serviceVariable %>.delete(headers, id);
            }
        <% } else if(action === 'autoComplete') { %>
            @Post('autoComplete')
            @ApiOperation({ operationId: 'autoComplete' })
            @ApiQuery({ name: 'query', type: String })
            @ApiBody({ description: 'Mongo DB Filter', type: () => Object })
            @ApiResponse({ status: 200, description: 'Success', type: <%= schemaAutoCompleteName %> })
            @ApiResponse({ status: 400, description: 'Bad Request' })
            @ApiResponse({ status: 404, description: 'Not Found' })
            @ApiResponse({ status: 500, description: 'Internal Error' })
            async findAutocomplete(
                @Headers() headers: ApiHeader,
                @Query('query') query: string,
                @Body() filter: Filter<<%= schemaName %>>,
            ) {
                return await this.<%= serviceVariable %>.autocomplete(headers, query, filter);
            }
        <% } else if(action === 'current') { %>
        <% } else { %>
            <% const api = it.apiSettings.find(item => item.action === action); %>
            <% if (api) { %>
                <% const hasBody = ['post', 'put', 'patch'].includes(api.method); %>

                <%
                    const paramsWithType = [];
                    const paramsWithoutType = [];

                    if(api.entryPoint && api.entryPoint.includes(':')) {
                        let subpath = api.entryPoint.split('/');
                        for(let a = 0; a < subpath.length; a++) {
                        const partstr = subpath[a];
                        if(partstr.includes(':')) {
                            const paraname = partstr.replace(':','');
                            paramsWithType.push(`${paraname}: string`);
                            paramsWithoutType.push(paraname);
                        }
                        }
                    }

                    if(api.queryPara && api.queryPara.length > 0) {
                        for(let q=0; q < api.queryPara.length; q++) {
                        const qp = api['queryPara'][q];
                        paramsWithType.push(`${qp}: string`);
                        paramsWithoutType.push(qp);
                        }
                    }

                    if(hasBody) {
                        paramsWithType.push(`data: ${getTypeName(api.schema)}`);
                        paramsWithoutType.push('data');
                    }
                %>

                @<%= upperFirstCase(api.method) %>('<%= api.entryPoint %>')
                @ApiOperation({ operationId: '<%= action %>', description: '<%= api.description %>' })
                <% if(api.queryPara && api.queryPara.length > 0) { %>
                    <% for(let q = 0; q < api.queryPara.length; q++) { %>
                        @ApiQuery({name: "<%=api['queryPara'][q]%>", required: false, type: String})
                    <% } %> 
                <% } %>
                <% if(hasBody) { %>
                    @ApiBody({ type: <%= getTypeName(api.schema) %> })
                <%}%>
                @ApiResponse({ status: 200, description: 'Success', type: <%= getTypeName(api.responseType) %> })
                @ApiResponse({ status: 400, description: 'Bad Request' })
                @ApiResponse({ status: 500, description: 'Internal Error' })
                async <%= action %>(
                    @Headers() headers: ApiHeader,
                    <%= paramsWithType.join(',') %>
                ){
                    return await this.<%= serviceVariable %>.<%= action %>(
                        headers,
                        <%= paramsWithoutType.join(', ') %>
                    );
                }
            <% } %>
        <% } %>
    <% }); %>
}