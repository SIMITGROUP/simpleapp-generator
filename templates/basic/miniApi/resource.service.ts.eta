<%
  const pascalName = upperFirstCase(it.resourceName);
  const apiName = it.typename.toUpperCase() + 'Api';
  const uglyName = upperFirstCase(it.name ?? '');
  const schemaName = `SimtrainSchema.${uglyName}`;
  const schemaAutoCompleteName = `SimtrainSchema.${uglyName}AutoComplete`;

  const getTypeName = (typeName) => {
    const systemTypes = ['boolean', 'string', 'number', 'object', 'integer'];
    let tmpTypeName = typeName.replace('[','').replace(']','');

    if(systemTypes.includes(tmpTypeName.toLowerCase())){
        tmpTypeName = upperFirstCase(tmpTypeName.toLowerCase());
    } else {
        tmpTypeName = `SimtrainSchema.${tmpTypeName}`;
    }

    if(typeName.includes('[')){
        return `[${tmpTypeName}]`;
    }

    return tmpTypeName;
  }
%>

import { BadRequestException, Injectable } from '@nestjs/common';
import _ from 'lodash';
import { <%= apiName %> } from 'src/openapi/backend-api';
import { ApiHeader } from 'src/types/api';
import { getOpenApiConfig } from 'src/utils/api';
import { ResourceApiListDto } from '../../dto/resource-api.schema';
import * as SimtrainSchema from '../../simtrain-schema';

@Injectable()
export class <%= pascalName %>Service {
  protected guards = {
    read: [],
    create: [],
    update: [],
  };

  constructor() {}

  private getApi(headers: Record<string, string>) {
    return new <%= apiName %>(getOpenApiConfig(headers));
  }

  <% Object.entries(it.miniApp.whitelistApis).forEach(([action, value]) => { %>
    <% if (value !== true && typeof value !== 'object') { return; } %>
    
    <% if(action === 'list') { %>
      async findAll(headers: ApiHeader, dto?: ResourceApiListDto<<%= schemaName %>>) {
        const api = this.getApi(headers);
        const resp = await api.runSearch({
          fields: dto?.fields,
          filter: dto?.filters,
          sorts: dto?.sorts as string[][] | undefined,
        });
        return resp.data;
      }
    <% } else if(action === 'detail') { %>
      async findOne(headers: ApiHeader, id: string) {
        const api = this.getApi(headers);
        const resp = await api.runFindOne(id);
        return resp.data;
      }
    <% } else if(action === 'create') { %>
      async create(headers: ApiHeader, resourceDto: any) {
        const api = this.getApi(headers);
        const resp = await api.runCreate(resourceDto);
        return resp.data;
      }
    <% } else if(action === 'update') { %>
      async update(headers: ApiHeader, id: string, resourceDto: any) {
        const api = this.getApi(headers);
        const resp = await api.runUpdate(id, resourceDto);
        return resp.data;
      }
    <% } else if(action === 'patch') { %>
      async patch(headers: ApiHeader, id: string, resourceDto: any) {
        const api = this.getApi(headers);
        const resp = await api.runPatch(id, resourceDto);
        return resp.data;
      }
    <% } else if(action === 'delete') { %>
      async delete(headers: ApiHeader, id: string) {
        const api = this.getApi(headers);
        const resp = await api.runDelete(id);
        return resp.data;
      }
    <% } else if(action === 'autoComplete') { %>
      async autocomplete(headers: ApiHeader, query: string, filter: any) {
        const api = this.getApi(headers);
        const resp = await api.autoComplete(query, filter);
        return resp.data;
      }
    <% } else if(action === 'current') { %>
    <% } else { %>
      <% const api = it.apiSettings.find(item => item.action === action); %>
      <% if (api) { %>
        <% const hasBody = ['post', 'put', 'patch'].includes(api.method); %>

        <%
          const paramsWithType = [];
          const paramsWithoutType = [];

          if(api.entryPoint && api.entryPoint.includes(':')) {
            let subpath = api.entryPoint.split('/');
            for(let a = 0; a < subpath.length; a++) {
              const partstr = subpath[a];
              if(partstr.includes(':')) {
                const paraname = partstr.replace(':','');
                paramsWithType.push(`${paraname}: string`);
                paramsWithoutType.push(paraname);
              }
            }
          }

          if(api.queryPara && api.queryPara.length > 0) {
            for(let q=0; q < api.queryPara.length; q++) {
              const qp = api['queryPara'][q];
              paramsWithType.push(`${qp}: string`);
              paramsWithoutType.push(qp);
            }
          }

          if(hasBody) {
            paramsWithType.push(`data: ${getTypeName(api.schema)}`);
            paramsWithoutType.push('data');
          }
        %>

        async <%= action %>(
          headers: ApiHeader,
          <%= paramsWithType.join(',') %>
        ){
          const api = this.getApi(headers);
          const resp = await api.run<%= upperFirstCase(action) %>(<%= paramsWithoutType.join(', ') %>);
          return resp.data;
        } 
      <% } %>
    <% } %>
  <% }) %>

}