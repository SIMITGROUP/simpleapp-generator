import { Injectable } from '@nestjs/common';
import { InjectModel } from '@nestjs/mongoose';
import { Model } from 'mongoose';
import Ajv from 'ajv';
import addFormats from 'ajv-formats';
import addKeyword from "ajv-keywords";


import * as <%= it.doctype %>type from './<%= it.doctype %>.type';
import * as <%= it.doctype %>apischema from './<%= it.doctype %>.apischema';

//import { <%= it.typename %> } from './<%= it.doctype %>.type';
//import { <%= it.apiSchemaName %> } from './<%= it.doctype %>.apischema';
import {
  NotFoundException,
  InternalServerErrorException,
} from '@nestjs/common/exceptions';
@Injectable()
export class <%= it.doctype %>Service {
  private jsonschema = <%~ JSON.stringify(it.jsonschema) %>;
  
  constructor(
    @InjectModel('<%= it.name %>') private readonly doc: Model<<%= it.fullTypeName %>>,
  ) {}

  getSchema() {
    return this.doc.schema.obj;
  }
  async list() {
    try {
      const products = await this.doc.find();
      const productlist = products.map((p: <%= it.fullTypeName %>) => {
        return p;
      });
      //   console.log(products);
      return productlist;
    } catch (err) {
      throw new InternalServerErrorException(err.message);
    }
  }
  async findById(id: string) {
    let data;

    try {
      data = await this.doc.findById(id);
    } catch (err) {
      //error
      throw new InternalServerErrorException(err.message);
    }

    if (!data) {
      //data not found
      throw new NotFoundException('Document Not found:');
    }
    return data;
  }
  async create(data: <%= it.fullTypeName %>) {
    let result;

    try {
      delete data._id;
      this.validateData(data);
      const newdoc = new this.doc(data);
      result = await newdoc.save();
    } catch (err) {
      throw new InternalServerErrorException(err.message);
    }
    return result as <%= it.fullTypeName %>;
  }
  async update(id: string, data: <%= it.fullTypeName %>) {
    const existingdata = await this.findById(id);
    try {
      this.validateData(data);
      const result = await existingdata.updateOne(data);
      return result;
    } catch (err) {
      throw new InternalServerErrorException(err.message);
    }
  }
  async delete(id: string) {
    const data = await this.findById(id);
    try {
      const deleteresult = await this.doc.findByIdAndDelete(id);
      return deleteresult;
    } catch (err) {
      throw new InternalServerErrorException(err.message);
    }
  }

  validateData(data: <%=it.doctype %>type.<%= it.typename %>) {
    const ajv = new Ajv({ allErrors: true });
    addFormats(ajv);
    ajv.addKeyword('example');

    const validate = ajv.compile(this.jsonschema);
    const valid = validate(data);    
    if (!valid) {
      console.log(validate.errors);
      const erromsg: string[] = [];
      for (let i = 0; i < validate.errors.length; i++) {
        erromsg.push(validate.errors[i].message);
      }
      throw new InternalServerErrorException(erromsg.join('\n'));
    }
  }
}
