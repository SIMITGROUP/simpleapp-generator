/**
 * This file was automatically generated by simpleapp generator. Every
 * MODIFICATION OVERRIDE BY GENERATEOR
 * last change 2025-06-18
 * Author: --
 */

<% 
  const upperFirstCase = (value) => {
    return value.charAt(0).toUpperCase() + value.slice(1);
  }

  const pascalName = upperFirstCase(it.resourceName);
  const apiName = it.typename.toUpperCase() + 'Api';
  const typeActionName = 'MiniApp' + pascalName + 'Actions';

  const miniAppWhitelistApis = it.jsonschema['x-simpleapp-config']?.miniApp?.whitelist || {};
  const hasMiniAppWhitelistedApi = Object.keys(miniAppWhitelistApis).length > 0;
%>

import { <%= apiName %> } from "~/simpleapp/generate/openapi";
import { MiniAppBridgeMessageApi } from "../../types/bridge.type";

const actions = <%~ JSON.stringify(Object.keys(miniAppWhitelistApis), null, 2) %> as const;

export type <%= typeActionName %> = (typeof actions)[number];

export class MiniApp<%= pascalName %>BridgeService {
  protected api!: <%= apiName %>;

  constructor(miniAppCode: string) {
    const config = getAxiosConfig();
    if(miniAppCode !== ""){
      config.baseOptions = {
        headers: {
          "x-mini-app-code": miniAppCode
        }
      }
    }
   
    this.api = new <%= apiName %>(config);
  }

  async handleApi(message: MiniAppBridgeMessageApi<<%= typeActionName %>>) {
    <% if(hasMiniAppWhitelistedApi) { %>
      const handlers = this.getHandlers();

      const handler = handlers[message.params.action];
      if (!handler) {
        throw new Error(`ERR_UNKNOWN_ACTION: ${message.params.action}`);
      }

      return await handler(message);
    <% } else { %>
      throw new Error(`ERR_NOT_SUPPORTED`);
    <% } %>
  }

  private getHandlers(): Record<
    <%= typeActionName %>,
    (message: MiniAppBridgeMessageApi<<%= typeActionName %>>) => Promise<any>
  > {
    <% if(hasMiniAppWhitelistedApi) { %>
      return {
        <% Object.entries(miniAppWhitelistApis).forEach(([action, value]) => { %>
          <% if (value !== true && typeof value !== 'object') { return; } %>

          <%
            const handlerName = "handle" + upperFirstCase(action);
          %>
          <%= action %>: this.<%= handlerName %>.bind(this),
        <% }) %>
      };
    <% } else { %>
      throw new Error(`ERR_NOT_SUPPORTED`);
    <% } %>
  }

  /****************************************** API Action *****************************************/

  <% Object.entries(miniAppWhitelistApis).forEach(([action, value]) => { %>
    <% if (value !== true && typeof value !== 'object') { return; } %>

    <% if(action === 'list') { %>
      protected async handleList(message: MiniAppBridgeMessageApi<<%= typeActionName %>>) {
        return (await this.api!.runSearch({})).data;
      }
    <% } else if(action === 'detail') { %>
      protected async handleDetail(message: MiniAppBridgeMessageApi<<%= typeActionName %>>) {
        if (!message.params.resource.id) throw new Error("ERR_MISSING_ID");
        return (await this.api!.runFindOne(message.params.resource.id)).data;
      }
    <% } else if(action === 'create') { %>
      protected async handleCreate(message: MiniAppBridgeMessageApi<<%= typeActionName %>>) {
        if (!message.params.body) throw new Error("ERR_MISSING_BODY");
        return (await this.api!.runCreate(message.params.body as any)).data;
      }
    <% } else if(action === 'update') { %>
      protected async handleUpdate(message: MiniAppBridgeMessageApi<<%= typeActionName %>>) {
        if (!message.params.resource.id) throw new Error("ERR_MISSING_ID");
        if (!message.params.body) throw new Error("ERR_MISSING_BODY");

        return (
          await this.api!.runUpdate(
            message.params.resource.id,
            // TODO: Type
            message.params.body as any,
          )
        ).data;
      }
    <% } else if(action === 'patch') { %>
      protected async handlePatch(message: MiniAppBridgeMessageApi<<%= typeActionName %>>) {
        if (!message.params.resource.id) throw new Error("ERR_MISSING_ID");
        if (!message.params.body) throw new Error("ERR_MISSING_BODY");

        return (
          await this.api!.runPatch(
            message.params.resource.id,
            // TODO: Type
            message.params.body as any,
          )
        ).data;
      }
    <% } else if(action === 'delete') { %>
      protected async handleDelete(message: MiniAppBridgeMessageApi<<%= typeActionName %>>) {
        if (!message.params.resource.id) throw new Error("ERR_MISSING_ID");

        return (await this.api!.runDelete(message.params.resource.id)).data;
      }
    <% } else if(action === 'autoComplete') { %>
      protected async handleAutoComplete(message: MiniAppBridgeMessageApi<<%= typeActionName %>>) {
        return (await this.api!.autoComplete(message.params.query ?? "", {})).data;
      }
    <% } else if(action === 'current') { %>
      protected async handleCurrent(message: MiniAppBridgeMessageApi<<%= typeActionName %>>) {
        return {};
      }
    <% } else { %>
      protected async handle<%= upperFirstCase(action) %>(message: MiniAppBridgeMessageApi<<%= typeActionName %>>) {
        <% const apiSetting = it.apiSettings.find(item => item.action === action); %>
        <% if (apiSetting) { %>
          const queryParams = message.params?.queryParams;

          <% const hasBody = ['post', 'put', 'patch'].includes(apiSetting.method); %>
          <% if (hasBody) { %>
            if (!message.params.body) throw new Error("ERR_MISSING_BODY");
          <% } %>
          <% 
            const paramMatches = apiSetting.entryPoint.match(/:([\w]+)/g) || [];
            const paramNames = paramMatches.map(p => p.replace(':', ''));
            paramNames.forEach(name => {
              if (name === 'id') {
          %>
            if (!message.params.resource.id) throw new Error("ERR_MISSING_ID");
          <%   } else { %>
            if (!queryParams?.<%= name %>) throw new Error("ERR_MISSING_QUERY_PARAM: <%= name %>");
          <%   }
            });
            
            // prepare args for the function call
            const args = paramNames.map(name => (
              name === 'id' 
                ? 'message.params.resource.id' 
                : `queryParams?.${name}`
            ));
            if (hasBody) args.push('message.params.body');
          %>

          return (await this.api!.run<%= upperFirstCase(action) %>(<%= args.join(', ') %>)).data;
        <% } %>
      }
    <% } %>
  <% }) %>
}